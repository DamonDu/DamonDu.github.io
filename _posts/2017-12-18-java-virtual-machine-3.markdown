---
layout:     post
title:      "深入理解Java虚拟机(三)"
subtitle:   "程序编译与代码优化"
date:       2017-12-18 22:00:00
author:     "Damon To"
header-style: text
catalog:    true
tags:
    - Java
---

> 这是我在阅读周志明版的《深入理解 Java 虚拟机》并进行知识复盘的时候整理出的知识大纲式的文档，第三部分主要关于程序编译与代码优化。至于书中最后一部分内容——Java 并发的内容我不打算精读，主要是并发十分复杂和重要，不是两个章节可以说清楚的，所以我打算在另外的专门讲 Java 并发的书籍中学习这部分内容。

### Before Reading

1. 本篇文章对应原书 10~11 章的内容。
2. 建议通读过原书的对应内容后再使用这份知识大纲。
3. 大部分内容为原书的摘抄，少部分是我自己的归纳。

### (一) 早期（编译期）优化

- **Java 中 3 类编译过程：**

  - 前端编译器：把 *.java 文件转变成 *.class 文件；例如 javac
  - 后端编译器/JIT 编译器（Just In Time Compiler）：把字节码转变成机器码；例如 HotSpot 的 C1/C2
  - AOT 编译器（Ahead Of Time Compiler）：直接把 *.java 文件编译成机器码；例如 Excelsior JET

- **javac 编译过程：**

  ![](/img/in-post/2017-12-18-java-virtual-machine-3/javac编译过程.png)

- **解析与填充符号表过程：**

  | 过程    | 实现类                            | 出口                              |
  | ----- | ------------------------------ | ------------------------------- |
  | 词法分析  | com.sun.tools.javac.Scanner    | 标记（Token）集合                     |
  | 语法分析  | com.sun.tools.javac.Parser     | 抽象语法树（Abstract Syntax Tree，AST） |
  | 填充符号表 | com.sun.tools.javac.comp.Enter | 待处理列表（To Do List）               |

- **符号表（Symbol Table）**是有一组符号地址和符号信息构成的表格

- **待处理列表**包含了每一个编译单元的抽象语法树的顶级节点，以及 package-info.java 的顶级节点（若存在）

- **注释处理器**可以读取、修改、添加抽象语法树中的任意元素。若处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有修改为止。每一次循环称为一次 **Round**

- **语义分析与字节码生成过程：**

  | 过程       | 内容                                       | 实现类                                      |
  | -------- | ---------------------------------------- | ---------------------------------------- |
  | 标注检查     | 检查变量使用前是否已被声明、变量与赋值的数据类型是否匹配等；进行常量折叠     | com.sun.tools.javac.comp.Attr </br>com.sun.tools.javac.comp.Check |
  | 数据及控制流分析 | 检查局部变量使用前是否赋值、方法的每条路径是否都有返回值、是否受查异常都正确处理等 | com.sun.tools.javac.comp.Flow            |
  | 解语法糖     | 将语法糖还原为基础语法结构                            | com.sun.tools.javac.comp.TranTypes </br>com.sun.tools.javac.comp.Lower |
  | 字节码生成    | 将语法树、符号表等信息转化为字节码并写入磁盘，并进行少量的代码添加和转化工作   | com.sun.tools.javac.jvm.Gen </br>com.sun.tools.javac.jvm.ClassWriter |

- **语法糖（Syntactic Sugar）：**指在计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是能方便程序员使用

- **Java 泛型 VS C# 泛型：**

  - C#：通过类型膨胀实现的真实泛型
  - Java：通过类型擦除实现的伪泛型；它的泛型指在源码中存在，在编译为字节码后就替换为原生类型（Raw Type），所以在运行期中 ArrayList\<int> 和 ArrayList\<String> 是相同的

### (二) 晚期（运行期）优化

- **解释器与编译器各有优势：**
  - 解释器可以让程序迅速启动和执行，且能节约内存
  - 编译器随着运行时间推移，把更多的代码编译为本地代码，执行效率更高
- HotSpot 虚拟机中解释器和编译器搭配使用，称为**混合模式（Mixed Mode）**，也可以通过参数设置为**解释模式（Interpreted Mode）**和**编译模式（Compiled Mode）**
- HotSpot 虚拟机中内置两个即时编译器，分别称为 **Client Compiler** 和 **Server Compiler**，也简称 **C1编译器**和 **C2 编译器**
- 为了在程序启动响应速度和运行效率之间取得最佳平衡，HotSpot 虚拟机采用**分层编译（Tiered Compilation）**，具体分为：
  - 第 0 层，解释执行，解释器不进行性能监控
  - 第 1 层，C1 编译，进行简单、可靠的优化，加入必要的性能监控
  - 第 2(+) 层，C2 编译，启动一些较为耗时的优化，以及一些需要根据性能监控来进行的不可靠的激进优化
- 热点代码包括两种：被多次调用的方法 & 被多次执行的循环体
- 对于**由循环体触发**的即时编译，编译器仍会以整个方法作为编译对象，这称为**栈上替换/ OSR 编译（On Stack Replacement）**
- **主要的热点探测判定方式有：**

| 方法                                       | 优点                 | 缺点                               |
| ---------------------------------------- | ------------------ | -------------------------------- |
| 基于采用的热点探测（Sample Based Hot Spot Detection） | 实现简单、高效；容易获取方法调用关系 | 难以精准确认一个方法的热度，容易受到线程阻塞或者其他外界因素影响 |
| 基于计数器的热点探测（Counter Based Hot Spot Detection） | 实现麻烦，不能直接获取方法的调用关系 | 统计结果更加精确和严谨                      |

- HotSpot 虚拟机使用**基于计数器的热点探测**，且为每个方法准备了两类计数器：**方法计数器（Invocation Counter）和回边计数器（Back Edge Counter）**

- **方法调用计数器触发的即时编译：**

  ![](/img/in-post/2017-12-18-java-virtual-machine-3/方法调用计数器触发的即时编译.png)

- 如果不做任何设置，方法调用计数器统计的是相对的执行频率，即一段时间内的调用次数。如果一定时间内，方法的调用次数没有达到阈值，那计数器值就会减少一半，这个过程称为**衰减（Counter Decay）**

- 回边计数器的阈值默认是间接计算得到：

  - Client 模式下：回边计数器阈值=方法调用计数器阈值 * OSR 比率/100
  - Server 模式下：回边计数器阈值=方法调用计数器阈值 * (OSR 比率 - 解释器监控比率)/100

- **回边计数器触发的即时编译：**

  ![](/img/in-post/2017-12-18-java-virtual-machine-3/回边计数器触发的即时编译.png)

- 回边计数器统计的是绝对次数，不存在热度衰减的过程

- **编译器的工作：**

  - 第一阶段：将字节码构成一种高级中间代码表示（High-Level Intermediate Representation，HIR）
  - 第二阶段：从 HIR 中产生低级中间代码表示（Low-Level Intermediate Representation，LIR）
  - 第三阶段：进行线性扫描算法（Linear Scan Register Allocation），在 LIR 上分配寄存器，产生机器代码

- **公共字表达式消除：**如果一个表达式 E 已经计算过，并从计算后到现在 E 中变量的值不变，那么 E 则成为公共子表达式，可直接用之前计算的结果代替 E

- 如果优化仅限于程序基本块内，则称为**局部公共子表达式（Local Common Subexpression Elimination）**；如果优化涵盖多个基本块，则称为**全局公共子表达式（Global Common Subexpression Elimination）**

- **数组边界检查消除（Array Bounds Checking Elimination）**：在即时编译器中，在编译期根据数据流分析来进行数组的越界检查，以避免在运行期每次进行边界检查

- **方法内联**：把目标方法的代码“复制”到发起调用的方法中，以避免发生真实的方法调用

- Java 虚拟机中，使用**类型继承关系分析（Class Hierarchy Analysis，CHA）**来确定目前已加载的类中，某个接口是否有多于一种的实现，某个类是否有子类、子类是否为抽象类等信息，从而解决虚方法的内联问题

- **Java 编译器内联：**

  ![](/img/in-post/2017-12-18-java-virtual-machine-3/Java编译器内联.png)

- **逃逸分析（Escape Analysis）**主要分析对象的动态作用域，分两种：

  - 方法逃逸：对象被外部方法引用，例如作为参数传递到其他方法
  - 线程逃逸：对象被外部线程访问到，例如赋值给类变量或在其他线程中访问的实例变量

- 若能证明一个对象不会逃逸，则可以进行如下优化：

  - **栈上分配（Stack Allocation）**：如果一个对象不会发生方法逃逸，则该对象可以在栈上分配内存。好处是对象会随栈帧出栈而销毁，减少 GC 的压力
  - **同步消除（Synchronization Elimination）**：如果一个对象不会发生线程逃逸，则对该对象的同步措施可以消除
  - **标量替换（Scalar Replacement）**：如果一个对象不会被外部访问，且该对象可拆散，则可以不创建该对象，而是直接创建若干被这个方法使用到的对象的成员变量来代替