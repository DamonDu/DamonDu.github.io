---
layout:     post
title:      "深入理解Java虚拟机读书笔记(二)"
subtitle:   "虚拟机执行子系统"
date:       2017-12-17 23:30:00
author:     "Damon To"
header-img: "img/java-virtual-machine.jpeg"
header-mask: 0.5
catalog:    true
tags:
    - Java
---

> 最近在看周志明版的《深入理解 Java 虚拟机》一书，觉得写得很好，十分适合 Java 学习者作为进阶学习的指导书籍。这是我在阅读这本书和进行知识复盘的时候整理出的知识大纲式的文档，第二部分主要关于 Java 虚拟机执行子系统。

### Before Reading

1. 本篇文章对应原书 6~8 章的内容。
2. 建议通读过原书的对应内容后再使用这份知识大纲。
3. 大部分内容为原书的摘抄，少部分是我自己的归纳。

### (一) 类文件结构

- **Class 文件格式**

| 类型             | 名称                  | 数量                    | 含义/作用                          |
| -------------- | ------------------- | --------------------- | ------------------------------ |
| u4             | magic               | 1                     | 魔数；确定该文件是否为一个能被虚拟机接受的 Class 文件 |
| u2             | minor_version       | 1                     | 次版本号                           |
| u2             | major_version       | 1                     | 主版本号                           |
| u2             | constant_pool_count | 1                     | 常量池容量计数值                       |
| cp_info        | constant_pool       | constant_pool_count-1 | 常量池；存放字面量与符号引用（从1开始计数）         |
| u2             | access_flags        | 1                     | 访问标识；用于识别一些类或接口层次的访问信息         |
| u2             | this_class          | 1                     | 类索引；确定该类的全限定名                  |
| u2             | super_class         | 1                     | 父类索引；确定该类的父类的全限定名              |
| u2             | interfaces_count    | 1                     | 接口计数器                          |
| u2             | interfaces          | interfaces_count      | 接口集合；描述该类实现了哪些接口               |
| u2             | fields_count        | 1                     | 字段计数器                          |
| field_info     | fields              | fields_count          | 字段表；描述接口或类中声明的变量               |
| u2             | methods_count       | 1                     | 方法计数器                          |
| method_info    | methods             | methods_count         | 方法表；描述接口或类中的方法                 |
| u2             | attributes_count    | 1                     | 属性计数器                          |
| attribute_info | attributes          | attributes_count      | 属性表；描述某些场景下专有的信息               |

- Class 文件每个字节代表什么含义，长度是多少，先后顺序如何，都是固定不能改变的。
- 常量池中主要存放两类常量：**字面量（Literal）**和**符号引用（Symbolic References）**：
  - 字面量如：文本字符串、声明为 final 的常量值等
  - 符号引用如：1. 类和接口的全限定名；2. 字段的名称和描述符；3. 方法的名称和描述符
- 字段（field）包括类级变量以及实例级变量，不包括方法内部声明的局部变量
- **区分：简单名称/描述符/全限定名**
  - 简单名称：没有类型和参数修饰的方法或者字段名称
  - 描述符：描述字段的数据类型、方法的参数列表和返回值（例："[[Ljava/lang/String"）
  - 全限定名：例"java/lang/String"
- 字段表（方法表）集合中不会列出继承而来的字段（方法），但会有编译器自动添加的源码中不存在的字段（方法）
- **Java 语言中**，重载的要求是：简单名称相同，特征签名不同，所以不能存在简单名称与特征签名都相同的两个方法；而**在 Class 文件中**，只要是描述符不完全相同的两个方法便可以共存（即允许存在简单名称与特征签名都相同的两个方法，返回值不同的两个方法）
- javac 编译器使用异常表而不是简单的跳转命令来实现 Java 异常和 finally 处理机制
- **区分 Exceptions 属性与异常表：**
  - Exceptions 属性与 Code 属性平级，作用是列举出方法中可能抛出的受查异常（Checked Exceptions）
  - 异常表属于 Code 属性，作用是实现 Java 异常和 finally 处理机制
- Signature 属性，用于记录泛型签名信息
- BootstrapMethods 属性，用于保存 invokedynamic 指令引用的引导方法限定符
- 在 Java 虚拟机指令集中，大多数指令都包含了其操作所对应的数据类型信息
- Java 编译器会在将 byte 和 short 型数据带符号扩展，将 boolean 和 char 类型数据零位扩展成对应的 int 类型数据
- **Java 类型转化**
  - 宽化类型转化（Widening Numeric Conversations）：小范围想大范围类型的转化，安全，虚拟机直接支持
  - 窄化类型转化（Narrowing  Numeric Conversations）：必须显式地使用转化指令

### (二) 虚拟机类加载机制

- **虚拟机类加载机制：**虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型
- **类的生命周期：**加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）；其中，验证/准备/解析这 3 个步骤也可以统称为连接（Linking）
- **有且只有** 5 种情况（**主动引用**）需要立即对类进行初始化：
  1. 遇到 new/getstatic/putstatic/invokestatic 时
  2. 使用 java.lang.reflect 包的方法对类进行反射调用时
  3. 当初始化一个类的时候，发现其父类还没有进行过初始化，则先要对父类进行初始化
  4. 当虚拟机启动时，初始化主类
  5. 如果一个 java.lang.invoke.MethodHandle 实例最后解析结果是 REF_getStatic / REF_putStatic / REF_invokeStatic 的方法句柄，且句柄对应的类没有进行过初始化时
- **被动引用**不会触发初始化，它包括：
  1. 通过子类引用父类的静态字段，不会导致子类初始化
  2. 通过数组定义来引用类，不会触发此类的初始化
  3. 常量在编译阶段会存入调用类的常量池中（常量传播优化），本质上并没有直接引用到定义常量的类，不会触发定义常量的类的初始化
- 接口加载与类加载的不同：第 3 种主动引用，**接口初始化时，不要求其父接口全部都完成了初始化**
- **区分类加载/加载：**类加载包含：加载、验证、准备、解析、初始化 5 个步骤；加载是类加载的一个阶段
- **加载阶段**，虚拟机需要完成 3 件事：
  1. 通过类的全限定名来获取定义类的二进制字节流
  2. 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
  3. 在内存中生成类的 java,lang.Class 对象，作为方法区这个类的各种数据的访问入口
- **非数组类的加载**，可以使用系统提供的引导类加载器来完成，也可以用用户自定义的类加载器完成；**数组类的加载**，由 Java 虚拟机直接创建
- **元素类型（Element Type）VS 组件类型（Component Type）**
  - 元素类型：数组去掉所有维度的类型
  - 组件类型：数组去掉一个维度的类型
- **验证阶段**的 4 个阶段的检验动作：
  1. 文件格式验证：字节流是否符合 Class 文件格式？版本兼容？
  2. 元数据验证：对类的元数据进行语义校验（语义分析）
  3. 字节码验证：数据流和控制流分析（语义分析）
  4. 符号引用验证：确保符号引用的解析动作能正常执行
- **区分：准备阶段/初始化阶段**
  - 准备阶段为类变量分配内存并设置类变量初始值，这里的初始值一般是数据类型的零值（常量字段设置为 ConstantValue 属性设置的值）
  - 初始化阶段则根据程序员通过程序指定的计划去初始化类变量和其他资源
- **解析阶段**将常量池内的符号引用替换为直接引用
- **符号引用（Symbolic References）VS 直接引用（Direct References）**
  - 符号引用用一组符号来描述所引用的墓表，符号可以是任何形式的字面量，与虚拟机实现的内存布局无关
  - 直接变量可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，和虚拟机实现的内存布局有关
- 虚拟机可以对一次解析的结果进行缓存以避免解析动作重复进行
- **初始化阶段**执行类构造器 \<clinit>() 方法。关于 \<clinit>() 方法：
  - \<clinit>() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生
  - 虚拟机会保证调用子类 \<clinit>() 方法时父类的 \<clinit>() 方法已经执行完毕
  - 执行接口的 \<clinit>() 方法不需要先执行其父接口的 \<clinit>() 方法
  - 如果一个类中没有类变量的赋值动作和静态语句块，则编译器可以不生成 \<clinit>() 方法
  - 虚拟机保证类的 \<clinit>() 方法在多线程环境下被正确地加锁、同步
- 静态语句块只能访问定义在静态语句块之前的变量，定义在它之后的变量在静态语句块中**只能赋值不能访问**
- **类加载器：**类加载阶段中，“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作是在 Java 虚拟机外部实现的，这个实现模块叫做“类加载器”
- 两个来自同一 Class 文件被不同的类加载器加载，则两个类不相等
- 类加载器一般分三种：
  - 启动类加载器（Bootstrap ClassLoader）：加载其他的所有类加载器
  - 扩展类加载其（Extension ClassLoader）：加载 \<JAVA_HOME>\lib\ext 中的，或者被 java.ext.dirs 指定的路径中的所有类库
  - 应用程序类加载器（Application ClassLoader）：架子用户类路径上所指定的类库
- **双亲委派模型（Parents Delegation Model）：**除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。
  - 这里的父子关系不是以继承（Inheritance）实现而是使用组合（Composition）来复用父加载器的代码
  - 只有当父加载器无法完成加载请求时，子加载器才会尝试自己加载（优先级：父加载器 > 子加载器）

### (三) 虚拟机字节码执行引擎

- **当前栈帧（Current Stack Frame）：**对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧。这个栈帧关联的方法称为**当前方法（Current Method）**

- **操作数栈（Operand Stack）：**也称操作栈，用于进行算术运算或方法参数传递，它是一个后入先出栈（LIFO）。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。

- 大多数虚拟机的实现中，会令两个栈帧出现一部分重叠，以减少参数复制传递。

- **正常完成出口（Normal Method Invocation Completion）：**返回地址是调用者的 PC 计数器的值，这个值存储在栈帧中；**异常完成出口（Abrupt Method Invocation Completion）：**返回地址要通过异常处理器来确定，不存储在栈帧

- **解析（Resolution）**

  - 前提：“编译器可知，运行期不可变”
  - 符合条件的有：静态方法、私有方法、实例构造器、父类方法（统称为非虚方法）、被 final 修饰的方法

- **静态类型（Static Type） VS 实际类型（Actual Type）**

  - 变量本身的静态类型不会改变，且是编译期可知的
  - 实际类型则在运行期才能确定

- **分派（Dispatch）**

  - 静态分派：依赖静态类型来定位方法执行版本的分派动作称为静态分派。典型应用是方法重载，重载版本并不是“唯一的”，往往只能确定一个“更合适的”版本
  - 动态分派：依赖实际类型来定位方法执行版本的分派动作。典型应用是重写。

- **invokevirtual 指令的运行时解析过程：**

  ![invokevirtual 指令的运行时解析过程](http://ompnv884d.bkt.clouddn.com/invokevirtual%20%E6%8C%87%E4%BB%A4%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png)

- **单分派/多分派：**方法的接收者与方法的参数统称为方法的宗量。单分派根据一个宗量对目标方法进行选择，多分派根据多个宗量对目标方法进行选择

- 直到目前，Java 是**“静态多分派，动态单分派”**

- **虚拟机动态分派的实现：**类在方法区建立一个虚方法表（Virtual Method Table）或接口方法表（Interface Method Table），表中存放这各个方法的实际入口地址，如果某个方法在子类没有被重写，则表中该方法的地址与父类的一致

- 解析与分派并不是二选一的排他关系，而是在不同层次上筛选、确定目标方法的过程

- Java 中实现动态类型语言：1.invokedynamic 指令；2. java.lang.invoke 包

- java.lang.invoke 包提供了除了依靠符号引用来确定调用目标方法以外的另外一种动态确定目标方法的机制，称为 **MethodHandle**。这种机制主要是通过**模拟字节码层面的方法调用**来实现的，所以可以服务于所有运行与 Java 虚拟机之上的语言。

- **基于栈的指令集 VS 基于寄存器的指令集：**基于栈的指令集的优点是可移植，代码更加紧凑，编译器实现更简单；缺点是执行速度较慢，指令数量较多