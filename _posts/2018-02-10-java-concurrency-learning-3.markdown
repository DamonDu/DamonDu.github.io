---
layout:     post
title:      " Java 并发学习笔记(三)"
subtitle:   "活跃性、性能与测试"
date:       2018-2-10 18:00:00
author:     "Damon To"
header-img: "img/java-concurrency.jpg"
header-mask: 0.6
catalog:    true
tags:
    - Java
    - Concurrency
---

> 这是我阅读[《 Java 并发编程实战》](https://book.douban.com/subject/10484692/)整理出的知识大纲，第三部分主要是关于活跃性问题的介绍和避免，性能的分析与优化以及如何对并发程序进行正确的测试。

### Before Reading

1. 本篇文章对应原书 10~12 章的内容。
2. 建议通读过原书的对应内容后再使用这份知识大纲。
3. 大部分内容为原书的摘抄，少部分是我自己的归纳。
4. 文章中的代码是从原书 example 中摘抄得来，你可以从[原书官网](http://jcip.net/listings.html)获取完整的代码。

### 避免活跃性危险

#### 死锁

* **锁顺序死锁**
  * 发生原因：两个线程试图**以不同的顺序来获得相同的锁**。
  * 检查：对加锁行为进行全局分析
  * 解决：如果所有线程以固定的顺序来获得锁，那么就不会发生锁顺序死锁；如果一个程序每次至多只能获得一个锁，那么就不会产生锁顺序死锁。
* **动态的锁顺序死锁**
  * 有时候，并不能清楚地知道是否在锁顺序上有足够的控制权来避免死锁的发生。锁的顺序可能取决于参数顺序，而参数顺序又取决于外部输入。
  * 解决：在指定锁顺序时，可以**使用 `System.identityHasdCode` 方法**。在极少数情况下，两个对象可能拥有相同的散列值。为了避免这种情况，可以使用**“加时赛（Tie-Breaking）”锁**。在获得两个 Account 锁之前，首先获得这个“加时赛”锁，从而保证每次只有一个线程以未知的顺序获得这两个锁。
* **协作对象之间发生的死锁**
  * 如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能会获取锁，或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。
  * **如果在持有锁的情况下调用某个外部方法，那么就需要警惕死锁**。
* **开放调用（Open Call）**：如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。
  * 通过开放调用可以避免死锁。
  * **应该尽可能地使用开放调用**：分析一个完全依赖于开放调用的程序的活跃性，要比分析那些不依赖开放调用的程序的活跃性简单。
  * 重新编写同步代码块可能会使得某个原子操作变为非原子操作。
* **资源死锁**
  * 当多个线程在相同的资源集合上等待时，也会发生死锁。
  * 原因：在请求两个或多个资源时不始终遵循相同的顺序；任务之间存在依赖，发生线程饥饿死锁。

#### 死锁的避免和诊断

* **限时锁**：使用 `Lock` 类中的定时 `tryLock` 功能来代替内置锁机制。
* **线程转储（Thread Dump）**：JVM 通过线程转储来帮助识别死锁的发生。线程转储包括各个运行中的线程的栈追踪信息以及加锁信息。JVM将在等待关系图中通过搜索循环来找出死锁。如果发现了一个死锁，则获取相应的死锁信息。

#### 其他活跃性问题

* **饥饿（Starvation）**：当线程由于无法访问它所需要的资源而不能继续执行时，就发生了饥饿。
  * 在大多数 Java 应用程序中，所有线程都具有相同的优先级，通过修改线程优先级所带来的**效果通常不明显**。而且只要改变了线程的优先级，程序的行为就将与平台相关。
* **活锁（Livelock）**：当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行时，就发生了活锁。
  * 解决：在重试机制中引入随机性。

### 性能与可伸缩性

#### 性能指标与性能影响因素

* 当操作性能由于某种特定的资源而受到限制时，我们通常将该操作称为资源密集型的操作，例如，CPU密集型、数据库密集型等。

* **要想通过并发来获得更好的性能，需要做好两件事情**

  * 更有效地利用现有处理资源。
  * 在出现新的处理资源时使程序尽可能地利用这些新资源。

* 性能可以采用多个指标来衡量，其中一些指标（服务时间、等待时间）用于衡量程序的**“运行速度”**，另一些指标（生产量、吞吐量）用于程序的**“处理能力”**。

* **可伸缩性**：当增加计算资源时，程序的吞吐量或者处理能力应当相应地增加。

  * 在进行可伸缩性调优时，其目的是设法将问题的计算并行化，从而能利用更多的计算资源来完成更多的工作。
  * 对于服务器应用程序来说，“多少”这个方面一一可伸缩性、吞吐量和生产量，往往比“多快”这个方面更受重视。

* 先使程序正确运行，然后再提高运行速度。

* 在使某个方案比其他方案“更快”之前，首先问自己一些问题：

  * “更快”的含义是什么？
  * 该方法在什么条件下运行得更快？在低负载还是高负载的情况下？大数据集还是小数据集？能否通过测试结果来验证你的答案？
  * 这些条件在运行环境中的发生频率？能否通过测试结果来验证你的答案？
  * 在其他不同条件的环境中能否使用这里的代码？
  * 在实现这种性能提升时需要付出哪些隐含的代价，例如增加开发风险或维护开销？这种权衡是否合适？

* **Amdahl 定律**：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。假定 F 是必须被串行执行的部分，那么根据 Amdahl 定律，在包含 Ⅳ 个处理器的机器中，最高的加速比为：
  $$
  Speedup \leq \frac{1}{F+\frac{(1-F)}{N}}
  $$





* 在所有的并发程序中都包含一些串行部分。

#### 线程开销与相应的优化

* **引入线程的开销**
  * 上下文切换：切换上下文的开销；在线程调度过程中需要访问由操作系统和 JVM 共享的数据结构；上下文切换会导致一些缓存缺失。
  * 内存同步：会抑制一些编译器的优化操作；竞争的同步会导致竞争失败线程的阻塞。
* **不用过于担心非竞争同步带来的开销**，它对应用程序的整体性能的影响十分微小。
* 减少锁的竞争可以提高性能和可伸缩性。在并发程序中，限制可伸缩性的最主要瓶颈就是**独占方式的资源锁**。
* **降低锁竞争程度的3个方向**
  * 减少锁的持有时间。
  * 降低锁的请求频率。
  * 使用带有协调机制的独占锁，允许更高的并发性。
* **减少锁竞争（提高可伸缩性）的具体方法**
  * **缩小锁的范围**：将一些锁无关的代码移出同步代码块（尤其是开销大的操作）。
  * **锁分解**：如果一个锁需要保护多个**相互独立**的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁被请求的频率。
  * **锁分段**：将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，这种情
    况被称为锁分段。
  * **避免热点域（Hot Field）**：一些常见的优化措施，例如将一些反复计算的结果缓存起来，都会引入一些“热点域”，而这些热点域往往会限制可伸缩性。
  * **使用其他方法替代独占锁**：使用一种**友好并发的方式**来管理共享状态。例如：并发容器、读 - 写锁、不可变对象以及原子变量。
* 如果在锁上存在**适中而不是激烈的竞争**时，通过将一个锁分解为两个锁，能最大限度地提升性能（因为实际上是把这些锁转变为非竞争的锁）；把一个**竞争激烈的**锁分解为两个锁时，这两个锁仍然可能都存在激烈的竞争，无法给可伸缩性带来极大的提高。
* **锁分段的一个劣势在于**：要获取多个锁来实现独占访问将更加困难并且开销更高。
* **监测 CPU 的利用率**：如果应用程序正在使 CPU 保持忙碌状态，那么可以使用监视工具来判断是否能通过增加额外的 CPU 来提升程序的性能。**如果 CPU 的利用率很高，并且总会有可运行的线程在等待 CPU**，那么当增加更多的处理器时，程序的性能可能会得到提升。
* **不使用对象池**：通常，对象分配操作的开销比保证对象池同步的开销更低。（除非对象的创建和销毁操作开销十分巨大，但这个时候一般是对象设计存在不合理）
* **减少上下文切换的开销**：一般是通过将异构任务分解。典型的例子是：在日志服务中，将 I/O 操作从日志处理请求的线程中分离出来。

### 并发程序的测试

#### 正确性测试

* 在为某个并发类设计单元测试时，首先要找出程序的**不变性条件和后验条件**。

* **对阻塞操作的测试**

  * 在测试并发的基本属性时，**需要引入多个线程**。大多数测试框架并不能很好地支持并发性测试，所以**需要通过一些工作将成功或失败信息传递回主测试线程**，从而才能将相应的信息报告出来。
  * 约定：每个测试必须等待它所创建的全部线程结束以后才能完成。
  * 简单的实现方式是：使用中断，在一个单独的线程中启动一个阻塞操作，等到线程阻塞后再中断它，然后宣告阻塞操作成功。
  * “等待并直到线程阻塞后”要求我们：估计执行这些指令可能需要多长的时间，并且等待的时间会更长。
  * **测试阻塞行为以及对中断的响应**：

  ```java
  // 完整代码：http://jcip.net/listings/TestBoundedBuffer.java
  void testTakeBlocksWhenEmpty() {
          final SemaphoreBoundedBuffer<Integer> bb = new SemaphoreBoundedBuffer<Integer>(10);
          Thread taker = new Thread() {
              public void run() {
                  try {
                      int unused = bb.take();
                      fail(); // if we get here, it's an error
                  } catch (InterruptedException success) {
                  }
              }
          };
          try {
              taker.start();
              Thread.sleep(LOCKUP_DETECT_TIMEOUT);
              taker.interrupt();
              
              taker.join(LOCKUP_DETECT_TIMEOUT);
              assertFalse(taker.isAlive());
          } catch (Exception unexpected) {
              fail();
          }
      }
  ```

  * 使用 `Thread.getState` 来验证线程能否在一个条件等待上阻塞，但这种方法
    并**不可靠**（线程可能通过自旋来实现阻塞）。

* **安全性测试**

  * 要想测试一个并发类在不可预测的并发访问情况下能否正确执行，需要创建多个线程来分别执行并发操作，并在执行一段时间后判断在测试中是否会出现问题。理论上，**测试线程之间产生更多的并发交替操作，则更有可能找出错误**。
  * 要开发一个良好的并发测试程序，或许比开发这些程序要测试的类更加困难。所以关键是：**找到容易测试以及容易发生错误的属性，并且在测试中尽量不需要任何同步机制**。
  * **提高测试效率**：使用两个 `CountDownLatch` （一个开始阀门，一个结束阀门），或者使用 `CyclicBarrier` ，可以让测试线程尽可能的并发交替操作。

* **资源管理的测试**

  * 检查程序有无发生资源泄露。
  * 使用测量程序中内存使用情况的堆检查工具。

* **使用回调函数**：通过在对象生命周期的一些已知位置上执行回调函数，可以判断在这些特定位置上的不变性条件有无得到保证。

* **使用 `Thread.yield`** ，可以产生更多的并发交替操作，提高发现并发错误的概率。

#### 性能测试

* **性能测试的目的**
  * 衡量应用程序中的端到端性能。
  * 根据经验值来调整各种不同的限值。
* **得到每个操作的运行时间**：使用一个栅栏动作来测量启动和结束时间，相减整个运行过程的时间，然后除以总操作的数量，从而得到每次操作的运行时间。
* **响应性衡量**
  * 两个方面：响应时间，响应时间的变动性。
  * **如果能获得更小的服务时间变动性，那么更长的平均服务时间是有意义的**。
  * 除非线程由于密集的同步需求而被持续地阻塞，否则**非公平**的信号量通常能实现**更好的吞吐量**，而**公平**的信号量则实现**更低的变动性**。
* **避开性能测试的陷阱**
  * **垃圾回收**：不可预测的垃圾回收会影响每次测试迭代的时间，从而让测试结果变得不可信。有两种解决方法：禁止测试时的垃圾回收；在测试时足够频繁地执行垃圾回收。
  * **动态编译**：动态编译的执行时间无法预测，会影响测试结果。三种解决方式：使测试程序运行足够长的时间；先运行被测试程序一段时间后再进行测试；在同一 JVM 上多次测试。
  * **对代码路径的不真实采样**：引入多线程的性能测试，即可避免编译器对代码路径的优化。
  * **不真实的竞争程度**：在并发测试中，应尽量模拟真实应用环境中的计算量和并发协调开销。
  * **无用代码的消除**：在正式产品和测试版本中，都应该选择“-server 模式”，从而提高消除无用代码的程度。同时，为了避免测试相关代码被当作无用代码消除，可以：**计算某个派生对象中域的散列值，并将其与一个任意值比较，若相等则输出一个无用且可以忽略的消息**。
* **其他的 QA 方法**：**质量保证（Quality Assurance，QA）**的目标应该是在给定的测试资源下实现最高的可信度。测试并非唯一的 QA 方法。
  * 代码审查
  * 静态分析工具
  * 面向方面的测试技术
  * 分析和监测工具