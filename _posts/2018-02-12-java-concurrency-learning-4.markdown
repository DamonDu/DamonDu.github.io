---
layout:     post
title:      " Java 并发学习笔记(四)"
subtitle:   "高级主题"
date:       2018-2-12 23:30:00
author:     "Damon To"
header-style: text
catalog:    true
tags:
    - Java
    - Concurrency
---

> 这是我阅读[《 Java 并发编程实战》](https://book.douban.com/subject/10484692/)整理出的知识大纲，第四部分主要是关于 Java 并发的高级内容，主要包括：显示锁、条件队列、AQS、原子变量、非阻塞算法以及 JVM 中关于并发的一些底层细节。

### Before Reading

1. 本篇文章对应原书 13~16 章的内容。
2. 建议通读过原书的对应内容后再使用这份知识大纲。
3. 大部分内容为原书的摘抄，少部分是我自己的归纳。
4. 文章中的代码是从原书 example 中摘抄得来，你可以从[原书官网](http://jcip.net/listings.html)获取完整的代码。

### 显式锁

#### Lock 与 ReentrantLock

* `Lock` 提供了一种**无条件的**、**可轮询的**、**定时的**以及**可中断的**锁获取操作，所有加锁和解锁的方法都是**显式的**。
* `ReentrantLock` 实现了 `Lock` 接口，提供了与 `synchronized` 相同的**互斥性和内存可见性** ；提供了可重入的加锁语义；支持在Lock接口中定义的所有获取锁模式；为处理锁的不可用性问题提供了更高的灵活性。
* **为什么要创建一种与内置锁如此相似的新加锁机制？**
  * 内置锁无法中断一个正在等待获取锁的线程。
  * 内置锁无法在请求获取一个锁时无限地等待下去。
  * 内置锁无法实现非阻塞结构的加锁规则。
* **`Lock` 加锁之后不会自动释放锁，必须在 `finally` 块中释放锁。**
* 可定时的与可轮询的锁获取模式是由 `tryLock` 方法实现的，它具有更完善的错误恢复机制，可以用于：避免死锁的发生；实现具有时间限制的操作。
* `locklnterruptibly` 方法能够在获得锁的同时保持对中断的响应。
* 在 `ReentrantLock` 的构造函数中提供了**两种公平性选择**：非公平的锁（默认）或
  公平的锁。
  * 在公平的锁上，线程将按照它们发出请求的顺序来获得锁。
  * 非公平的锁上，则**允许“插队”**：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。

#### 公平性

* **公平性 VS 非公平性**：公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能。但在实际情况中，确保被阻塞的线程能最终获得锁（也就是**非公平**，或者说是**统计上的公平保证**）通常已经够用了，并且实际开销也小得多。
* 激烈竞争下，**非公平锁的性能高于公平锁的性能的一个原因是**：在恢复一个被挂
  起的线程与该线程真正开始运行之间存在着严重的延迟。
* **应该优先使用 `synchronized`** ：使用内置锁，代码更加简洁紧凑，而且更不容易出错。所以应把 `ReentrantLock` 作为一种高级工具，在需要一些高级功能时才使用。
* **互斥通常是一种过于强硬的加锁规则**，虽然可以避免“写/写”冲突和“写/读”冲突，但同样也避免了“读/读”冲突。

#### 读/写锁

* **读/写锁**：一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。
* **读/写锁 VS 互斥锁**：对于在多处理器系统上被频繁读取的数据结构，读/写锁能够提高性能。而在其他情况下，读/写锁的性能比互斥锁的性能要略差一些：这是因为它们的复杂性更高。
* `ReadWriteLock` 中的一些可选实现：释放优先；读线程插队；重入性；降级；升级。
* **在非公平的锁中**，线程获得访问许可的顺序是不确定的。写线程降级为读线程是可以的，但**从读线程升级为写线程则是不可以的**（这样做会导致死锁）。

### 构建自定义的同步工具

#### 状态依赖性的管理

* 依赖状态的操作可以一直阻塞直到可以继续执行，这比使它们先失败再实现起来要更为方便且更不易出错。
* **处理前提条件失败的方法**
  * **将前提条件的失败传递给调用者**：实现简单，但使用复杂，调用者必须做好捕获异常的准备。
  * **通过轮询和休眠来实现简单的阻塞**：将前提条件的管理操作封装起来，使调用者无须在每次调用时都实现重试逻辑。但对调用者提出了一个新的需求：处理 `InterruptedException`。
  * **使用条件队列**：使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真。与使用“休眠”相比，条件队列并没有改变原来的语义。它只是在多个方面进行了优化：CPU效率、上下文切换开销和响应性等。
* **每个对象可以作为一个条件队列**，并且 `Object` 中的 `wait`、`notify` 和 `notifyAII` 方法就构成了内部条件队列的 API。
* `Object.wait` 会**自动释放锁**，并请求操作系统挂起当前线程，从而使其他线程能够获得这个锁并修改对象韵状态。当被挂起的线程醒来时，它将在**返回之前重新获取锁**。

#### 使用条件队列

* **条件谓词**：条件谓词是使某个操作成为状态依赖操作的前提条件。要想正确地使用条件队列，关键是找出对象在哪个条件谓词上等待。
* **锁对象和条件队列对象必须是同一个对象。**
* **每一次 `wait` 调用都会隐式地与特定的条件谓词关联起来。**当调用某个特定条件谓词的 `wait` 时，调用者必须已经持有与条件队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量。
* `wait` 方法的返回并不一定意味着线程正在等待的条件谓词已经变成真了。所以，每当线程从 `wait` 中唤醒时，都**必须再次测试条件谓词**，如果条件谓词不为真，那么就继续等待（或者失败）。
* **总结：当使用条件等待时**（`Object.wait` 或 `Condition.await`）
  * 通常都有一个条件谓词：包括一些对象状态的测试，线程在执行之前必须首先通过这些测试。
  * 在调用 `wait` 之间测试条件谓词，并且从 `wait` 中返回时再次测试。
  * 在一个循环中调用 `wait`。
  * 确保使用与条件队列相关的锁来保护构成条件谓词的各个状态变量。
  * 当调用 `wait`、`notify` 或 `notifyAll` 等方法时，一定要持有与条件队列相关的锁。
  * 在检查条件谓词之后以及开始执行相应的操作之前，不要释放锁。
* **丢失的信号**：线程必须等待一个已经为真的条件，但在开始等待之前没有检查条件谓词。
* **通知**：每当在等待一个条件时，一定要确保在条件谓词变成真时通过某种方式发出通知。
  * `notify` ：从这个条件队列上等待的多个线程中选择一个来唤醒。
  * `notifyAII` ：会唤醒所有在这个条件队列上等待的线程。
* **发出通知的线程应该尽快地释放锁**：如果这些等待中线程此时不能重新获得锁，那么无法从 `wait` 返回，因此发出通知的线程应该尽快地释放锁，从而确保正在等待的线程尽可能快地解除阻塞。
* **应该优先选择 `notifyAll` 而不是单个的 `notify`** ：单一的通知很容易导致类似于信号丢失的问题。
  * 只有同时满足：所有等待线程的类型都相同（同个条件谓词）、单进单出这两个条件时，才应该使用 `notify`。
* **当只有一个线程可以执行时，如果使用 `notifyAll` ，那么将是低效的。**调用 `notifyAll` 将唤醒每个线程，并使得它们在锁上发生竞争，然后，它们中的大多数或者全部又都回到休眠状态。
* **条件通知（Conditional Notification）**：仅当操作影响到状态转换时，才发出通知，这也被称为条件通知。条件通知可以提升性能，但很难实现。
* 在使用条件通知或单次通知时，一些**约束条件使得子类化过程变得更加复杂**。两个设计类时的解决方法是：
  1. 将其等待和通知等协议完全向子类公开（并且写入正式文档）：例如公开条件队列和锁、条件谓词和同步策略、一些底层的状态变量。
  2. 禁止子类化。
* 通常，我们应该把条件队列封装起来，但这与“使用对象的内置锁来保护对象自身的状态”冲突。
* **入口协议和出口协议（Entry and Exit Protocols）**：描述 `wait` 和 `notify` 方法的正确使用。
  * 入口协议就是该操作的条件谓词。
  * 出口协议则包括，检查被该操作修改的所有状态变量，并确认它们是否使某个其他的条件谓词变为真，如果是，则通知相关的条件队列。
* `Condition` ：一种**广义的**内置条件队列。
  * 内置条件队列存在一些缺陷，每个内置锁都只能有一个相关联的条件队列。
  * `Condition` 更加灵活：在每个锁上可存在多个等待、条件等待可以是可中断的或不可中断的、基于时限的等待，以及公平的或非公平的队列操作。
  * 创建一个 `Condition` ，可以在相关联的 `Lock` 上调用 `Lock.newCondition` 方法。
  * 如果需要一些高级功能，那么应该优先使用 `Condition` 而不是内置条件队列。
* **AbstractQueuedSynchronizer(AQS)** ：AQS 是一个用于构建锁和同步器的框架，许多同步器都可以通过 AQS 很容易并且高效地构造出来。
  * AQS 负责管理同步器类中的状态，它管理了一个整数状态信息，可以通过 `getState` ，`setState` 以及 `compareAndSetState` 等 `protected` 类型方法来进行操作。
  * 提供了最基本的获取操作和释放操作，可选地支持独占或共享的获取操作。
  * 提供了一些机制来构造与同步器相关联的条件变量。

### 原子变量与非阻塞同步机制

#### 硬件对并发的支持

* 在针对多处理器操作而设计的处理器中提供了一些特殊指令，用于管理对共享数据的并发访问。例如：**比较并交换（Compare-and-Swap，CAS）**或者**关联加载/条件存储（Load-Linked/Store-Conditional）**。
* **CAS 的含义**是：“我认为 V 的值应该为 A，如果是，那么将V的值更新为 B，否则不修改并告诉 V 的值实际为多少”。
* CAS 是一项乐观的技术，它希望能成功地执行更新操作，并且**如果有另一个线程在最近一次检查后更新了该变量，那么 CAS 能检测到这个错误。并且，失败的线程不会挂起，而是被告知失败并可以重试**。
* **CAS 的典型使用模式**是：首先从 V 中读取值 A，并根据 A 计算新值 B，然后再通过 CAS 以 C 子方式将 V 中的值由 A 变成 B（只要在这期间没有任何线程将v的值修改为其他值）。
* **CAS VS 锁**：当竞争程度不高时，基于 CAS 的同步器在性能上远远超过了基于锁的同步器，而在没有竞争时甚至更高。

#### 原子变量类

* **原子变量**
  * 原子变量比锁的粒度更细，量级更轻，它将发生竞争的范围缩小到单个变量上。
  * 更新原子变量的快速（非竞争）路径不会比获取锁的快速路径慢，并且通常会更快，而它的慢速路径肯定比锁的慢速路径快，因为它不需要挂起或重新调度线程。
  * 能够支持原子的和有条件的读 - 改 - 写操作。
* **原子变量 VS 锁**：在高度竞争的情况下，锁的性能将超过原子变量的性能，但**在更真实的竞争情况下，原子变量的性能将超过锁的性能**。

#### 非阻塞算法

* **非阻塞算法**：如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。
* **无锁（Lock-Free）算法**：如果在算法的每个步骤中都存在某个线程能够执行下去，那么这种算法也被称为无锁算法。
* 非阻塞算法虽然实现复杂，但是能提升性能，而且通常不会出现死锁和优先级反转这些问题。
* **创建非阻塞算法的关键**在于，找出如何将原子修改的范围缩小到单个变量上，同时还要维护数据的一致性。
* [使用 Treiber 算法构造非阻塞栈。](http://jcip.net/listings/ConcurrentStack.java)
* [使用 Michael-Scott 算法构造非阻塞链表。](http://jcip.net/listings/LinkedQueue.java)
* **ABA问题**：在使用 CAS 时，如何确定“自从上次看到V的值为A以来，这个值是否发生了变化？”（如果在算法中采用自己的方式来管理节点对象的内存，那么就可能出现ABA问题）。

### Java 内存模型

#### 内存模型

* 各种各样的因素导致**线程无法看到变量的最新值**，所以从开发者的角度，如果没有进行同步处理，那么线程的内存操作看上去是以乱序执行。
  * 在单线程中，JVM 能保证在线程中维护一种**类似串行的语义**：即会保证线程的执行结果与以严格串行模式执行的结果一致。
  * 然而在多线程中，由于 JVM 维护这种串行语义将导致很大的开销，所以需要由开发者提供额外的同步操作来保证正确性。
* **JMM**：JMM 规定了 JVM 必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对于其他线程可见。
* 在不同的处理器架构中提供了不同级别的**缓存一致性（Cache Coherence）**，其中一部分只提供最小的保证，即允许不同的处理器在任意时刻从同一个存储位置上看到不同的值。
* **串行一致性**：程序执行一种简单假设：想象在程序中只存在唯一的操作执行顺序，而不考虑这些操作在何种处理器上执行，并且在每次读取变量时，都能获得在执行序列中（任何处理器）最近一次写入该变量的值。这种乐观的模型就被称为串行一致性。
* **重排序**：各种使操作延迟或者看似乱序执行的不同原因，都可以归为重排序。
* 同步将限制编译器、运行时和硬件对内存操作重排序的方式，从而在实施重排序时不会破坏 JMM 提供的可见性保证。
* **Happens-Before**：JMM 为程序中所有的操作定义了一个偏序关系，称之为 Happens-Before 。要想保证执行操作 B 的线程看到操作A的结果（无论A和B是否在同一个线程中执行），那么在A和B之间必须满足 Happens-Before 关系。
* **借助（Piggyback）同步** ：将 Happens-Before 的程序顺序规则与其他某个顺序规则结合起来，从而对某个未被锁保护的变量的访问操作进行排序。
* 借助同步容易出错，需要谨慎使用。

#### 初始化的安全性

* **提前初始化（Eager Initialization）**

  ```java
  //完整代码：http://jcip.net/listings/EagerInitialization.java
  public class EagerInitialization {
      private static Resource resource = new Resource();

      public static Resource getResource() {
          return resource;
      }

      static class Resource {
      }
  }
  ```

* 不要使用**双重检查加锁（DCL）**，因为线程可能看到一个失效的状态值。

* **初始化安全性**将确保，对于对正确构造的对象，所有线程都能看到由构造函数为对象给各个 final 域设置的正确值，而不管采用何种方式来发布对象。而且，由某个 final 域到达的任意变量将同样对于其他线程是可见的。**对于通过非 final 域可达的值，或者在构造过程完成之后可能改变的值，必须采用同步来确保可见性。**





