---
layout:     post
title:      "深入理解Java虚拟机(一)"
subtitle:   "自动内存管理机制"
date:       2017-12-13 23:00:00
author:     "Damon To"
header-img: "img/java-virtual-machine.jpeg"
header-mask: 0.5
catalog:    true
tags:
    - Java
---

> 大概有一个月的时间没有更新博客，原因大概是近段时间没有做什么实操性的项目，而是在看一些比较理论性的内容。最近主要在看的书是周志明版的《深入理解 Java 虚拟机》一书，觉得写得很好，十分适合 Java 学习者作为进阶学习的指导书籍。这是我在阅读这本书和进行知识复盘的时候整理出的知识大纲式的文档，第一部分主要关于 Java 虚拟机的自动内存管理机制。

### Before Reading

1. 本篇文章对应原书 2~3 章的内容。
2. 建议通读过原书的对应内容后再使用这份知识大纲。
3. 大部分内容为原书的摘抄，少部分是我自己的归纳。

### (一) Java 内存区域与内存溢出异常

* **运行时数据区域：**

  | 区域     | 作用                                 | 线程共享/私有                | 异常                                       |
  | ------ | ---------------------------------- | ---------------------- | ---------------------------------------- |
  | 程序计数器  | 当前线程所执行的字节码的行号指示器。                 | 线程私有；多线程切换时线程计数器之间互不影响 | 无                                        |
  | 虚拟机栈   | 描述 Java 方法的内存模型。                   | 线程私有                   | SatckOverflowError<br />OutOfMemoryError |
  | 本地方法栈  | 描述 Native 方法的内存模型。                 | 线程私有                   | SatckOverflowError<br />OutOfMemoryError |
  | Java 堆 | 存放对象实例                             | 线程共享                   | OutOfMemoryError                         |
  | 方法区    | 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等 | 线程共享                   | OutOfMemoryError                         |

* 如果执行的是一个 Java 方法，那么程序计数器记录当前字节码的地址；如果执行的是一个 Native 方法，则计数器值为 Undefined。

* **栈帧（Satck Frame）**：存储着方法的局部变量表、操作数栈、动态链接、方法出口等信息。是用于支持虚拟方法调用和方法执行的数据结构，每**一个方法从调用到执行完成对应栈帧从入栈到出栈。**

* **局部变量表（Loca Variable Table）**：是一组变量值存储空间，用于存放编译期可知的各种基本数据类型、对象引用和 returnAddress 类型。其最小单位称为**变量槽（Variable Slot，Slot）**。局部变量表中的 Slot 可以重用，当代码执行超出局部变量的作用域时，这个局部变量所占的 Slot 可以被其他局部变量所使用

* **Java 虚拟机栈 VS 本地方法栈**：

  * 服务对象不同：Java 方法 / Native 方法
  * 对本地方法栈中方法使用的语言、使用方式与数据结构没有规定

* Java 堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可。

* **方法区 VS 永久代：**两者并不等价。只是 HotSpot 将 GC 分代收集拓展至方法区（也就是说用永久代来实现方法区），分别内存管理与垃圾回收。

* **直接内存：**JDK 1.4 开始，使用 NIO 类直接分配堆外内存，在一些场景下可以避免在 Java 堆和 Native 堆之间来回复制，从而提升性能。


* **对象创建过程：**

  ![对象创建](http://ompnv884d.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.png)

* 为对象分配内存时，选择哪种分配方式取决于内存是否规整，内存是否规整取决于垃圾收集器是否有整理功能

* **解决并发时创建对象的线程安全问题：**

  1. 对分配内存空间的动作进行同步处理
  2. 把分配内存空间的动作按照线程划分在不同的空间中进行

* **对象的内存布局：**

  1. 对象头（Header）
     1. 对象的运行时数据（哈希码、GC分代年龄...）
     2. 类型指针
  2. 实例数据（Instance Data）
  3. 对齐填充（Padding）

* 实例数据的存储顺序由虚拟机分配策略参数和字段在 Java 源码的定义顺序决定。

* **对象的访问定位：**

  1. 使用句柄实现
  2. 使用直接指针实现 

*  **句柄实现 VS 直接指针实现：**使用句柄的好处是 reference 存储的是固定的句柄地址，不随对象的移动而移动；使用直接指针的好处是相对句柄访问速度更快（少了一次指针定位的开销）。

### (二) 垃圾收集器与内存分配策略

* 垃圾收集器面向的内存区域是 **Java 堆与方法区**

* **判断对象是否存活：**

  | 算法      | 基本思想                                     | 优点              | 缺点               |
  | ------- | ---------------------------------------- | --------------- | ---------------- |
  | 引用计数算法  | 给对象添加一个引用计数器，每当有一处引用则计数器值加1；引用失效时计数器值减1  | 实现简单且效率高        | 难以解决对象之相互循环引用的问题 |
  | 可达性分析算法 | 选定 GC Roots 作为起始节点，从这些节点开始向下搜索，搜索经过的路径称为引用链。当一个对象到 GC Roots没有任何引用链相连则证明该对象是不可用的 | 解决了对象之相互循环引用的问题 |                  |

* **GC Roots:**

  1. 虚拟机栈中引用的对象
  2. 方法区中类静态属性引用的对象
  3. 方法区中常量引用的对象
  4. 本地方法栈中 JNI 引用的对象

* **引用：**

  1. 强引用（Strong Reference）：存在则对象永远不会被回收
  2. 软引用（Soft Reference）：发生内存溢出异常时回收
  3. 弱引用（Weak Reference）：下一次 GC 时回收
  4. 虚引用（Phantom Reference）：对对象生存时间完全没有影响

* 回收方法区：废弃常量、无用的类

* **“无用的类”的三个条件：**

  1. 类的所有示实例都被回收
  2. 类的 ClassLoader 被回收
  3. 类的 java.lang.Class 对象没有被引用

* **垃圾收集算法：**

  | 算法                              | 基本思想                                     | 优点                    | 缺点                            |
  | ------------------------------- | ---------------------------------------- | --------------------- | ----------------------------- |
  | 标记-清除算法（Mark-Sweep）             | 先标记出所有需要回收的对象，标记后统一回收所有被标记的对象            | 最基础的算法                | 1.效率问题；2.空间问题：回收后产生大量不连续的内存碎片 |
  | 复制算法（Copying）                   | 将可用内存等分成两块，每次使用其中一块，当这一块内存用完时，将存活的对象复制到另一块，然后再把使用过的内存清理掉 | 不用考虑内存碎片的情况；按序分配，简单高效 | 内存缩小为原来的一半；对象存活率高是效率低         |
  | 优化的复制算法                         | 将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor，回收时，将存活的对象复制到另一块 Survivor，然后再把使用过的内存清理掉 | 保留复制算法的优点同时避免了大量内存浪费  | 对象存活率高是效率低                    |
  | 标记-整理算法（Mark-Compact）           | 先标记出所有需要回收的对象，标记后让所有存活对象向一段移动，然后直接清理掉端边界以外的内存 | 适合对象存活率高的情况           | 对象存活率低时效率不如复制算法               |
  | 分代收集算法（Generational Collection） | 根据对象存活周期不同将对象分为不同年代，根据各个年代的特点采用最合适的收集算法  | 当前商业虚拟机采用的垃圾收集算法      |                               |

* GC 对执行时间敏感的原因是：GC进行时必须停顿所有 Java 执行程序（GC 停顿）。

* 在 HotSpot 虚拟机中，使用一组名为 **OopMap** 的数据结构存储对象内数据的偏移量和类型、以及引用的位置，以实现准确式 GC

* **安全点（Safepoint）**：程序只有执行到安全点才会暂停下来进行 GC

* GC 中断方案：抢先式中断（Preemptive Suspension）、主动式中断（Voluntary Suspension）

* **安全区域（Safe Region）**：指在一段代码片段中，引用关系不会发生变化。在这个区域任意地方执行 GC 都是安全的。

* 垃圾收集器：

  | 收集器                   | 特点                          | 优点                                       | 缺点                                       |
  | --------------------- | --------------------------- | ---------------------------------------- | ---------------------------------------- |
  | Serial 收集器            | 单线程                         | 简单高效；适合运行在 Client 模式下的虚拟机                | GC 时必须暂停其他所有的工作线程                        |
  | ParNew 收集器            | 多线程；新生代                     | 唯一能与 CMS 收集器配合的收集器；在多 CPU 下能取得较好的效果      | 单 CPU 下性能不如 Serial 收集器                   |
  | Parallel Scavenge 收集器 | 吞吐量可控                       |                                          |                                          |
  | Serial Old 收集器        | 单线程；老年代                     | 适合 Client 模式下的虚拟机；在 Server 模式下：1.与 Parallel Scavenge 搭配使用  2.作为 CMS 收集器的预备方案 | 在 Server 模式下与 Parallel Scavenge 搭配使用无法充分利用服务器多 CPU 的能力 |
  | Parallel Old 收集器      | Parallel Scavenge 收集器的老年代版本 | 适合注重吞吐量以及 CPU 资源敏感的情况                    |                                          |
  | CMS 收集器               | 以获取最短回收停顿时间为目标              | 并发收集、低停顿                                 | 1.对 CPU 资源敏感；2.无法处理浮动垃圾；3.收集后产生内存碎片（标记-清除） |
  | G1 收集器                | 面向服务端应用                     | 并行并发；分代收集；空间整合；停顿可预测                     |                                          |

* **CMS 收集器处理步骤：**

  1. 初始标记（CMS initial mark）：标记 GC Roots 能直接关联的对象；需要暂停其他工作进程；耗时短
  2. 并发标记（CMS concurrent mark）：进行 GC Roots Tracing；不需要暂停其他工作进程；耗时长
  3. 重新标记（CMS remark）：修正并发标记期间用户程序运作导致的记录变动；需要暂停其他工作进程；耗时短（比初始标记长）
  4. 并发清除（CMS concurrent sweep）：进行垃圾回收；不需要暂停其他工作进程；耗时长

* 使用 G1 收集器时，Java 堆分成多个大小相等的 **Region**，G1 跟踪每个 Region 的回收价值并维护一个优先列表，优先回收价值最大的 Region

* 在 G1 收集器中，虚拟机使用 **Remember Set** 来避免全堆扫描

* **G1 收集器处理步骤：**

  1. 初始标记（initial mark）：标记 GC Roots 能直接关联的对象，修改 TAMS 的值；需要暂停其他工作进程；耗时短
  2. 并发标记（concurrent mark）：进行 GC Roots Tracing；不需要暂停其他工作进程；耗时长
  3. 最终标记（final mark）：修正并发标记期间用户程序运作导致的记录变动（将 Remember Set Logs 的数据合并到 Remember Set）；需要暂停其他工作进程；耗时短
  4. 筛选回收（live data counting and evacuation）：对各个 Region 的回收价值和成本进行排序，根据期望的 GC 停顿时间进行部分回收；可并发，停顿用户线程以提高收集效率

* **内存分配规则：**

  1. 对象优先分配在 Eden 区，Eden 去空间不足时进行 Minor GC

  2. 大对象直接进入老年代

  3. 长期存活对象进入老年代

  4. 动态对象年龄判断：如果 Survivor 区中相同年龄的对象大小综合大于 Survivor 空间的一般，年龄大于等于该年龄的对象直接进入老年代

  5. 空间分配担保：

     ![空间分配担保](http://ompnv884d.bkt.clouddn.com/%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D.png)
