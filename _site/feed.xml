<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SplitMusic</title>
    <description>Unity &amp; Music | Damon To, student in SYSU | </description>
    <link>https://damondu.github.io//</link>
    <atom:link href="https://damondu.github.io//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 06 Dec 2018 02:49:51 +0800</pubDate>
    <lastBuildDate>Thu, 06 Dec 2018 02:49:51 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>互联网角落的「Soulmate」</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;两个月前，我开始了自己的第一段实习，所在部门的主体业务是依附于手机 QQ 上的一个基于 LBS 的陌生人社交入口——「附近」。虽然做的是后台开发，但是出于对陌生人社交这个场景的好奇，两个月以来也从产品和业务的角度了解到不少这个领域的现状。同时，之前和产品同事聊天时聊到了 Soul 这款非典型陌生人社交 App，产生了不少的思考。这篇文章，尝试着从产品角度讲讲 Soul，也谈谈陌生人社交的现状和未来的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;soul-与心灵社交&quot;&gt;Soul 与「心灵社交」&lt;/h3&gt;

&lt;p&gt;Soul 是一款主打&lt;strong&gt;性格测试+算法推荐&lt;/strong&gt;的陌生人交友 APP，其主体功能——「心灵社交」的逻辑也足够简单：首先，用户首次进入时进行一次简单的”灵魂测试“；接着，依据测试结果，每个用户会落在不同的”星球“上；最后，当用户点击”Matching“进行系统匹配时，系统结合用户所在“星球”和其他性格特征来匹配“合拍度”高的其他用户。通过将 ”用户调研→生成用户画像→算法推荐“ 的流程进行了形象化地封装，再加上适度的引导，Soul 很大程度地抹除了用户对流程的天然反感，也契合产品自身的调性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/soul_use_logic.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;    
	&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;     color: #999;padding: 1px;&quot;&gt;一次「心灵社交」的简要流程&lt;/div&gt; 
&lt;/center&gt;

&lt;p&gt;除了产品主体逻辑，Soul 还有一个重要的分支功能——&lt;strong&gt;「广场」&lt;/strong&gt;，这是一个基于 UGC 的 Feeds 流。用户可以在「广场」发布自己的「瞬间」，发布的「瞬间」将会被其他用户所看到，并且可以进行点赞、评论、转发等互动。相比与匹配后聊天的&lt;strong&gt;同步互动&lt;/strong&gt;，基于 UGC 的点赞、评论等&lt;strong&gt;异步互动&lt;/strong&gt;显然起到很重要的互补功能。同时，「瞬间」会以 Timeline 形式展示在个人资料卡中，这也为用户提供了一个快速深入地了解其他 Souler 的途径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「匿名」和「语音」是 Soul 的两个重要元素。&lt;/strong&gt;从「广场」、「瞬间」，到用户的个人资料卡，再到不允许用户上传自定的头像，Soul 在其每个功能角落都消灭了“用户名称”这个概念；而「语音」也贯穿于每一个用户流程之中：从匹配时可选的“语音匹配”，到聊天时的“语音聊天”，再到支持了语音内容的「广场」。通过这两个元素，用户之间就像是“戴着面具在耳边低语”。在我看来这是个颇具未来感的交友场景：用户之间在感官上似乎离得很近，但实则彼此之间一无所知。这种产品设定下所营造的交友氛围是神秘而又克制的，这也使得 Soul 在一众陌生人社交软件中显得独特和出奇。&lt;/p&gt;

&lt;h3 id=&quot;souler-的社交窘境&quot;&gt;Souler 的社交窘境&lt;/h3&gt;

&lt;p&gt;Soul 固然有许多亮点：它开辟了社交的另一种玩法，没有走基于 LBS 的陌生人社交老路，也不像 TBH 一样基于完全的匿名化的激进玩法。它完全地依赖于推荐算法来进行社交关系的探索，看似是十分可行和美好的道路，但在实际中却存在种种风险和许多亟待完善的产品逻辑。&lt;strong&gt;“Souler 正处于一种社交窘境之中”——是我在深度体验了两个月产品后对当前的 Soul 的一个初步评价。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;用户社区缺乏活水&quot;&gt;用户社区缺乏活水&lt;/h4&gt;

&lt;p&gt;虽然 Soul 的运营现状算是稳中有升，但也一直处于一个不温不火的尴尬状态。它虽然有超过 40% 的次月留存率，但 DAU 却长期维持在三四十万的数量&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，可见其鼓吹的「心灵社交」并没能受到所有用户的买单。它另类的定位和小众的风格一方面缩小了目标受众的范围，另一方面让忠实用户得以圈地自萌。这种忠实用户的圈地维持着它可观的留存率的同时，也提高了新用户进入的门槛。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/soul_dau.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;    
	&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;     color: #999;padding: 1px;&quot;&gt;Soul 日活跃用户数量趋势分析&lt;/div&gt; 
&lt;/center&gt;

&lt;p&gt;活水的缺失对于社交软件是绝对的颓势，它应该是最需要解决、优先级最高的问题。&lt;/p&gt;

&lt;p&gt;Soul 应该在产品与社区中强化对新用户的引导和体验保护。我曾在 Soul 社区中发起过一次小型调研，多数用户在完成了系统匹配之后会先查看匹配到的用户的时间轴，只有在时间轴中发现了他感兴趣的内容时才会主动发起聊天，这对于还未发表内容的新用户来说无疑是一种恶劣体验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我认为「时间轴」这个功能是可以做删减。&lt;/strong&gt;「时间轴」的初衷可以理解为为用户提供一个初步了解的入口，帮助陌生用户之间的“破冰”。但实际上，这个功能让用户形成了“先看动态再聊天”的用户习惯。而从社交心理的角度，未知的人与事更能引发我们的兴趣。将过于“具体”的「时间轴」更改成模糊且有限的用户画像描述，或许更能诱发聊天的产生，同时也避免了给新用户带来体验上的落差。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/soul_timeline.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;    
	&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;     color: #999;padding: 1px;&quot;&gt;模糊化的用户描述是否更能引起聊天欲望？&lt;/div&gt; 
&lt;/center&gt;

&lt;h4 id=&quot;内容分发逻辑&quot;&gt;内容分发逻辑&lt;/h4&gt;

&lt;p&gt;Soul 当前的用户发布质量是足够优秀的，仅计算每日官方话题的用户发布率也能达到3.75%左右（在每天一个官方话题的频率下可以维持每个话题平均1.5~2万的参与度，DAU 40W）。然而这些 UGC 并没能转化为社区互动热度。分析其原因：一方面，目前大多数发布内容仍然是以文字为主，而且还存在许多大段文字，文字内容带来互动是及其有限的；另一方面，Feeds 流存在许多以私人情绪为主且表意混杂的低质 UGC。&lt;/p&gt;

&lt;p&gt;Soul 在 Feeds 流上的推荐算法逻辑从体验上看“时间”是占比权重最大的因子，但是对于优质内容的引流和强化推送是缺失的。它对优质内容的引流几乎只通过在一定时间内置顶来做。对于“我”这种希望在 Feeds 流看到更多优质内容的用户，只有一个置顶的优质内容是远远不足的。关于这里的内容分发该怎么做是存在权衡的：优质内容分发比例过多，会减少普通用户的流量，普通用户难以被发现；优质内容分发比例过少，则 Feeds 流质量下降，用户粘性也会随之下降。&lt;/p&gt;

&lt;p&gt;参考业内的解决方案，例如抖音是怎么做的？抖音的做法更像是&lt;strong&gt;把优质内容和实时内容的比例参数化和动态化&lt;/strong&gt;，虽然不知道其背后的算法实现，但这种思路是可以效仿的。&lt;/p&gt;

&lt;h3 id=&quot;当我们谈论陌生人社交&quot;&gt;当我们谈论陌生人社交&lt;/h3&gt;

&lt;p&gt;陌生人社交的玩法早已不是那个“左滑右滑”就可以解决的时代了，从直播，到视频聊天，再到游戏社交，各种各样的玩法和功能在陌生人社交软件里诞生和试验，说明了这个领域还存在着许多潜在的用户需求没有被挖掘和满足。&lt;/p&gt;

&lt;p&gt;今天，当我们再次谈论起陌生人社交时，简单地套用“约炮软件”的刻板印象已经不在适用。当我们在谈论陌生人社交时，我们再也避不开以下几个课题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;UGC 平台：如何做一个好的 Feeds 流？如何高效地分发内容？如何提高 UGC 的质量？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系的建立和维护：如何做好用户破冰？如何做有效地用户引导？如何避免用户关系下沉到微信等IM工具？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户社区的运营：如何提高用户的互动热度？如何营造符合产品气质的用户社区氛围？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安全监管：如何过滤有风险的用户内容？如何提高平台的监管力度？&lt;/p&gt;

    &lt;p&gt;……&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;张小龙早年曾说：互联网的最终目的，是让关系学见鬼去。&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;我想如果有一个互联网产品能深刻地改变关系学，那它一定不会是像微信一般用于“维护关系”的 IM 工具，更有可能地，它的形态会更接近于以“探索关系”和“建立关系”为使命的陌生人社交。我期待着见证这样一款改变人类关系学的互联网产品的诞生。&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Soul 运营数据来自易观千帆。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;引自看完了张小龙的 2359 条饭否日记，https://zhuanlan.zhihu.com/p/20539834。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 12 Sep 2018 15:00:00 +0800</pubDate>
        <link>https://damondu.github.io//2018/09/12/soulmate-at-internet-corner/</link>
        <guid isPermaLink="true">https://damondu.github.io//2018/09/12/soulmate-at-internet-corner/</guid>
        
        <category>产品</category>
        
        
      </item>
    
      <item>
        <title>项目总结：近期的两个小项目</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;近期为了应对校招面试，比较有针对性地做了两个技术项目：一个是基于 Java NIO 实现的简易版非阻塞 Http 服务器，另一个是基于 Spring Boot + Websocket 实现的网络聊天室。与以往的项目总结不同，这次我会忽略一些代码实现细节，把更多的篇幅用来总结开发过程中我遇到的难题以及在面试中面试官提出的相关问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;基于-java-nio-实现的简易版非阻塞-http-服务器&quot;&gt;基于 Java NIO 实现的简易版非阻塞 Http 服务器&lt;/h3&gt;

&lt;p&gt;首先需要强调的是，这种 &lt;a href=&quot;https://github.com/DamonDu/nio-server&quot;&gt;Http 服务器的实现&lt;/a&gt;是非常朴素直接的，没有考虑很多具体实践中的问题。最近在看&lt;a href=&quot;https://www.amazon.com/Netty-Action-Norman-Maurer/dp/1617291471&quot;&gt;《Netty In Action》&lt;/a&gt;才越来越感觉之前做项目时想法上的过于单纯。但项目本身其实十分适合初学者进阶的，因为其中涉及到的知识：Java NIO、网络多路复用、Http 报文解析、缓冲区设计，都是十分重要的基础问题，也是在校招技术面试中面试官喜欢深入考察的问题。在开发过程中，我借鉴了 &lt;a href=&quot;http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-non-blocking-server.html&quot;&gt;Java NIO: Non-blocking Server非阻塞服务器&lt;/a&gt;这篇文章的思路，上面提及的几个关键问题文章中也有较为详细的解析。&lt;/p&gt;

&lt;h4 id=&quot;项目基本架构&quot;&gt;项目基本架构&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/nio-aarchitecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;java-bionioaio&quot;&gt;Java BIO/NIO/AIO&lt;/h4&gt;

&lt;p&gt;关于 Java BIO/NIO/AIO 这三者的区别，个人觉得 &lt;a href=&quot;https://www.programering.com/a/MDM0YzMwATE.html&quot;&gt;Java BIO, NIO, AIO understanding&lt;/a&gt; 这篇文章总结得十分简洁到位，作者分别从编程、原理、底层三方面进行总结。编程方面作者讲解的十分到位，而要理解原理部分可能需要一些 Unix 网络编程的相关知识，以下就做一些网络编程相关的补充：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unix 网络编程中将 IO 模型分为五类：阻塞 IO、非阻塞 IO（轮询）、IO 复用、信号驱动式 IO、异步 IO。其中非阻塞 IO（轮询）、IO 复用、信号驱动式 IO 都可以理解为非阻塞 IO 的不同形式实现。（&lt;a href=&quot;https://blog.csdn.net/lihao21/article/details/51620374&quot;&gt;图解UNIX的I/O模型&lt;/a&gt;一文可以让你快速理解 Unix 中的 IO 模型）&lt;/li&gt;
  &lt;li&gt;无论是属于哪种 IO 模型，其 IO 过程都可以分为两个阶段： IO request（数据请求）和 IO operation（数据复制）两个阶段。&lt;/li&gt;
  &lt;li&gt;阻塞 IO 与非阻塞 IO 的区别在于：使用阻塞 IO 时，线程在 IO request 和 IO operation 阶段都会进入阻塞；而使用非阻塞 IO 时，线程只在 IO operation 阶段进入阻塞，IO request 无需阻塞。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同步 IO 与异步 IO 的区别在于：同步 IO 在 IO operation 阶段会进入阻塞，而异步 IO 在 IO request 和 IO operation 阶段都不会进入阻塞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;按照 Unix 网络编程中对 IO 模型的分类，Java BIO/NIO/AIO 的实现分别对应了阻塞 IO/IO 多路复用/异步 IO 这三种模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bio-vs-nio&quot;&gt;BIO vs NIO&lt;/h4&gt;

&lt;p&gt;Java AIO（在 JDK 1.7 中也称为 NIO.2），在性能上相较于 NIO 并没有带来提升，所以在 Netty 4.0.0 中也&lt;a href=&quot;https://github.com/netty/netty/issues/2515&quot;&gt;移除了对 AIO 的支持&lt;/a&gt;。无论是在实际应用中还是在技术面试中都较少提及 AIO，这里我们重点比较一下 BIO 与 NIO 的区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;处理的对象：BIO 直接面向 Socket 的字节流，每次从流中读一个或多个字节，直到读取完所有字节；NIO 面向缓冲块（Block），需要时可以在缓冲区中前后移动处理，这增加了处理过程的灵活性。&lt;/li&gt;
  &lt;li&gt;阻塞：BIO 必须要对线程进行阻塞，NIO 无需阻塞，一个单独的线程可以管理多个输入和输出通道。&lt;/li&gt;
  &lt;li&gt;选择器：Java NIO的选择器允许一个单独的线程同时监视多个通道，可以注册多个通道到同一个选择器上，然后使用一个单独的线程来“选择”已经就绪的通道。&lt;/li&gt;
  &lt;li&gt;零拷贝：Java NIO中提供的 &lt;code class=&quot;highlighter-rouge&quot;&gt;FileChannel&lt;/code&gt; 拥有 &lt;code class=&quot;highlighter-rouge&quot;&gt;transferTo&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;transferFrom&lt;/code&gt; 两个方法，可直接把 &lt;code class=&quot;highlighter-rouge&quot;&gt;FileChannel&lt;/code&gt; 中的数据拷贝到另外一个 Channel，或者直接把另外一个 Channel 中的数据拷贝到 &lt;code class=&quot;highlighter-rouge&quot;&gt;FileChannel&lt;/code&gt; 。通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也&lt;strong&gt;避免了两次用户态和内核态间的上下文切换&lt;/strong&gt;，也即使用了“零拷贝”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;总结自：&lt;a href=&quot;http://www.jasongj.com/java/nio_reactor/&quot;&gt;Java进阶（五）Java I/O模型从 BIO到 NIO和 Reactor模式&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;http-报文及解析&quot;&gt;HTTP 报文及解析&lt;/h4&gt;

&lt;p&gt;项目中对 HTTP 协议的支持也做了简化处理：只判别了 GET、POST、HEAD、PUT、DELETE 五种方法，主要是基于 HTTP 的 Content-Length 字段来实现 HTTP 报文切割（处理 TCP 粘包问题）。但是在面试中，HTTP 协议几乎是所有面试官会深究的一部分内容。大概涉及的问题如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 报文格式：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/Http-format.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Method 有哪些？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 常见状态码有哪些？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 建立 TCP 长连接？（Connection：Keep-Alive）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/52d86558ca57&quot;&gt;HTTP 1.0/1.1/2.0 之间的区别？&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;message-缓冲区设计&quot;&gt;Message 缓冲区设计&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;读取不完整的 message：每次 Reader 从 Channel 读取一个数据块后，先&lt;strong&gt;通过一个 Http 报文 parser 来确定是否有一个完整的 message&lt;/strong&gt;。若有，则读取一个完整的 message 后将剩余部分缓存起来；若无，则直接将整个数据块缓存起来。缓存的数据块将在下次读取时与下次读取的数据块合并，再进行重新的 parsing。&lt;/li&gt;
  &lt;li&gt;message buffer 的大小：MessageBuffer 实现了一个容量可伸缩的 message buffer。它提供三种大小的 buffer，4KB/128KB/1MB。初始时 buffer 默认为 4KB，若空间不足时，MessageBuffer 内部的方法会自动将 buffer 扩容。&lt;/li&gt;
  &lt;li&gt;message buffer 的读写：仿写了 &lt;code class=&quot;highlighter-rouge&quot;&gt;nio.Buffer&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;flip()&lt;/code&gt; 函数（&lt;code class=&quot;highlighter-rouge&quot;&gt;readPos&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;writePos&lt;/code&gt;），在 message buffer 的读写操作中调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;flip()&lt;/code&gt; 来避免错读、漏读。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;生产者-消费者队列&quot;&gt;生产者-消费者队列&lt;/h4&gt;

&lt;p&gt;用一个 ArrayBlockingQueue 来存放 socket，创建两个线程，acceptor 和 processor 分别使用其 put / take 操作来进行生产和消费。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 ArrayBlockingQueue：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;基于数组，直接将对象放入和取出队列。（LinkedBlockingQueue 基于单向链表，放入与取出时操作 Node）&lt;/li&gt;
    &lt;li&gt;基于一个 ReentrantLock 和两个 Condition（notEmpty 和 notFull） 实现。（LinkedBlockingQueue 基于两个 ReentrantLock ：putLock 和 takeLock 和两个 Condition：notEmpty 和 notFull 实现）&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;基于-spring-boot--websocket-实现的网络聊天室&quot;&gt;基于 Spring Boot + Websocket 实现的网络聊天室&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/DamonDu/websocketchat&quot;&gt;项目实现了一个简单的网络聊天室&lt;/a&gt;，基于 Spring Boot 搭建后台，基于 Websocket 与 STOMP 协议实现即时通讯，使用 Spring Security 与 Spring Oauth 实现用户登录，基于 JWT 实现对单点登录的支持。&lt;/p&gt;

&lt;h4 id=&quot;oauth-验证流程&quot;&gt;Oauth 验证流程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/springbootwebsocket.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;websocket-协议&quot;&gt;Websocket 协议&lt;/h4&gt;

&lt;p&gt;参考&lt;a href=&quot;http://www.infoq.com/cn/articles/deep-in-websocket-protocol&quot;&gt;WebSocket协议深入探究&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;jwt&quot;&gt;JWT&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;JWT(Json Web Token) 一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串形式，三部分组成：头部（Header）、载荷（Payload）、签名（Signature）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;头部：用于描述 JWT&lt;/p&gt;

    &lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;typ&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;JWT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;alg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;HS256&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;指定签名的加密算法&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;载荷：真正需要传递的内容 + 部分其他信息&lt;/p&gt;

    &lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iss&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;User JWT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1441593502&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;exp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1441594722&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;aud&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;www.example.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sub&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sub@example.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;from_user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;target_user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;签名：用于在服务端判断 JWT 的内容是否经过篡改，使用 JWT 头部指定的加密算法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;格式：header.payload.signature（先通过 base64 将 JSON 转化为字符串）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;载荷内容可以通过 base64 反编码获得，所以不应用 JWT 传输敏感数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用场景：添加好友、创建订单、实现单点登录&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 12 Jun 2018 00:25:00 +0800</pubDate>
        <link>https://damondu.github.io//2018/06/12/learn-from-interview/</link>
        <guid isPermaLink="true">https://damondu.github.io//2018/06/12/learn-from-interview/</guid>
        
        <category>NIO</category>
        
        <category>Websocket</category>
        
        <category>JWT</category>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>Java 沉思录(二)：关于 String</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;很长时间没有写「Java 沉思录」这个系列。前段时间学习一些比较进阶一点的 Java 知识，但回头看看最基础的 String 类，越发觉得往往越基础的知识反而越重要。这篇文章基于 JDK 源码出发，希望能纠正我们对 String 类的一些误解。同时强烈地推荐来自 ImportNew 社区的这篇&lt;a href=&quot;http://www.importnew.com/18167.html&quot;&gt;《探秘 Java 中 String、StringBuilder以及StringBuffer》&lt;/a&gt;，文章由浅入深，并且结合了一些面试中和应用中的实际问题，是一篇很好的技术博客。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;一-为什么说-string-是不可变的&quot;&gt;(一) 为什么说 String 是不可变的？&lt;/h3&gt;

&lt;p&gt;Java 中 String 是不可变的。这句话几乎是每个 Java 初学者第一句深刻记忆的句子，但是其背后的原因是什么。我们尝试从 JDK 源码出发进行分析，JDK 中 String 的部分源码如下：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Serializable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CharSequence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** The value is used for character storage. */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[];&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** Cache the hash code for the string */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Default to 0&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** use serialVersionUID from JDK 1.0.2 for interoperability */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialVersionUID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6849794470754667710L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** Class String is special cased within the Serialization Stream Protocol. */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObjectStreamField&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialPersistentFields&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObjectStreamField&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“String 是不可变的” 这个观点是正确的，但&lt;strong&gt;关于其原因的解释却容易有以下这些误区&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;错误一：因为 String 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; 的。&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;  修饰类时代表该类不可以被继承，而非不可变。&lt;/li&gt;
  &lt;li&gt;错误二：因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; 字段是 &lt;code class=&quot;highlighter-rouge&quot;&gt;fina&lt;/code&gt; 的。&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; 修饰字段时，若字段是基础类型则意味着字段不可变；而在这里修饰的 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; 字段是引用类型，这意味着引用是固定的，但其引用的具体内容（即数组内容）仍是可变的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实如果&lt;strong&gt;我们只从 String 的字段角度看，是无法确定它是不可变的。我们需要结合 String 的方法来看。&lt;/strong&gt;我们挑出 String 其中一个方法的实现：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldChar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newChar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldChar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newChar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* avoid getfield opcode */&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldChar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldChar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newChar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 返回一个新的字符串&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;replace&lt;/code&gt; 方法是新手最容易错误使用的方法之一。它的作用是返回一个将原字符串中所有为 &lt;code class=&quot;highlighter-rouge&quot;&gt;oldChar&lt;/code&gt; 的字符替换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;newChar&lt;/code&gt; 的字符。新手如果忘记 String 是不可变的，往往会认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;replace&lt;/code&gt; 方法会对原字符串修改。然而实际上 &lt;code class=&quot;highlighter-rouge&quot;&gt;replace&lt;/code&gt; 并不修改原字符串，它只是&lt;strong&gt;返回了一个进行了字符替换的新的字符串&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;无独有偶，其实 &lt;strong&gt;String 中的每个方法都不修改原字符串，而是返回一个新的字符串。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然 &lt;strong&gt;String 类本身没有提供修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; 的方法，而我们又无法继承和改写 String，所以 String 自然是不可变的。&lt;/strong&gt;（这里我们不考虑通过反射来进行修改的情况）&lt;/p&gt;

&lt;h3 id=&quot;二-string-与字符串常量重用&quot;&gt;(二) String 与字符串常量重用&lt;/h3&gt;

&lt;p&gt;String 的不可变性使得字符串重用的实现变得简单，而字符串重用带来的是减少对象创建带来的性能上的优化。例如下面代码：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;str&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;str&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Java 字符串常量的重用，与之前我们在 &lt;a href=&quot;http://splitmusic.cn/2017/12/17/java-virtual-machine-2/&quot;&gt;深入理解Java虚拟机(二)：虚拟机执行子系统&lt;/a&gt; 中讨论的类加载机制密不可分：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Class 文件的常量池（称为 Class 文件常量池）存放着字面量与符号引用&lt;/li&gt;
    &lt;li&gt;运行时 JVM 方法区的常量池（称为运行时常量池）存放对应的字面量与符号引用&lt;/li&gt;
    &lt;li&gt;类加载时，JVM 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。其中就包括了将 Class 文件常量池的字面量和符号引用加载到方法区的运行时常量池中。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;JVM 加载上面的两个语句所在的类时，会有如下现象：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Class 文件常量池存放两个 ”str“ 字面量&lt;/li&gt;
  &lt;li&gt;运行时，在创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;str1&lt;/code&gt; 时，JVM 检查&lt;strong&gt;运行时常量池&lt;/strong&gt;，没有找到 ”str“ 这个字面量，于是创建该字面量并将其引用赋值给 &lt;code class=&quot;highlighter-rouge&quot;&gt;str1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;str2&lt;/code&gt; 时，JVM 再次检查&lt;strong&gt;运行时常量池&lt;/strong&gt;，这次由于运行时常量池已有 ”str“ 字面量，根据字符串重用的机制，JVM 不重复创建字面量，而是将原有的 ”str“ 的引用直接赋值给 &lt;code class=&quot;highlighter-rouge&quot;&gt;str2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可以进行如下测试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(str1 == str2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果输出必然为 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; ，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;str1&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;str2&lt;/code&gt; 本就是相同的引用。&lt;/p&gt;

&lt;p&gt;这里的代码存在另一种需要区分的情况：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String str3 = new String(&quot;str&quot;);
String str4 = new String(&quot;str&quot;);
System.out.println(str3 == str4);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的输出为 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; 。通过 new 来创建 String，将会在堆区创建不同的对象，对象引用自然也就不同。&lt;/p&gt;

&lt;h3 id=&quot;三-stringstringbuilderstringbuffer&quot;&gt;(三) String、StringBuilder、StringBuffer&lt;/h3&gt;

&lt;p&gt;String 的不可变性带来了便捷，但也带来了一些不便。不便在于，当我们需要多次地修改某个 String 对象时，直观地看，由于 String 的不可变，似乎每次修改都需要重新 new 一个 String 实例，这将带来极大地空间浪费和 GC 压力。JDK 设计者为了规避这种不便，在&lt;strong&gt;底层的实现中采用可变的 StringBuilder 来避免频繁地对象创建&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们以 String 中实现字符串拼接的 &lt;code class=&quot;highlighter-rouge&quot;&gt;join()&lt;/code&gt; 方法为例：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharSequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delimiter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CharSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requireNonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delimiter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requireNonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Number of elements not likely worth Arrays.stream overhead.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;StringJoiner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;joiner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringJoiner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delimiter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharSequence&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;cs:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;joiner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;joiner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;join()&lt;/code&gt; 本身并不实现具体的字符串拼接，而是交由 &lt;code class=&quot;highlighter-rouge&quot;&gt;joiner&lt;/code&gt; 来实现。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringJoiner&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharSequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;prepareBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prepareBuilder()&lt;/code&gt; 顾名思义，创建并初始化了一个 StringBuilder 对象。在这里可以看出，String 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;join()&lt;/code&gt;方法在实现中是基于 StringBuilder 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;append()&lt;/code&gt; 方法实现。也正是由于这个优化，才提高了在使用 ”+“ 对多个字符串进行拼接时的性能。&lt;/p&gt;

&lt;p&gt;而至于 StringBuffer，除了和 StringBuilder 一样是可变的之外，还增加了多线程下的线程安全保证。所以在这三者之间进行选择时，一是我们要&lt;strong&gt;根据字符串修改是否频繁来决定使用 String 还是 StringBuilder 和 StringBuffer&lt;/strong&gt;；二是要&lt;strong&gt;根据是否处于多线程环境来决定使用 StringBuilder 或是 StringBuffer&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;参考资料：&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;探秘 Java中 String、StringBuilder以及 StringBuffer： &lt;a href=&quot;http://www.importnew.com/18167.html&quot;&gt;http://www.importnew.com/18167.html&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;JDK 之 String 源码阅读笔记：&lt;a href=&quot;https://emacsist.github.io/2017/07/01/JDK-%E4%B9%8B-String-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/&quot;&gt;https://emacsist.github.io/2017/07/01/JDK-%E4%B9%8B-String-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 13 Mar 2018 11:25:00 +0800</pubDate>
        <link>https://damondu.github.io//2018/03/13/ruminations-on-java-2/</link>
        <guid isPermaLink="true">https://damondu.github.io//2018/03/13/ruminations-on-java-2/</guid>
        
        <category>Java</category>
        
        <category>JDK</category>
        
        
      </item>
    
      <item>
        <title>Java Web 开发(二)：配置 SSM 框架</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Java Web 开发中，SSH 框架（Struts + Spring + Hibernate）和 SSM 框架（Spring + SpringMVC + MyBatis）是最常见的两个集成框架。它们很好地利用了 Spring IoC 特性，极大程度地减少了代码量和降低了代码之间的耦合度。之前看了一些 Spring Core 和 SpringMVC 的内容，但总觉得对 IoC 和 AOP 等概念没有很深刻的理解。通过这次动手配置 SSM 框架，真的是深刻体会到 Spring IoC 和 Bean 在实际开发中的重要意义。&lt;/p&gt;

  &lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/DamonDu/ssmTest&quot;&gt;https://github.com/DamonDu/ssmTest&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;一-项目回顾&quot;&gt;(一) 项目回顾&lt;/h3&gt;

&lt;p&gt;在上次 Java Web 项目：&lt;a href=&quot;http://splitmusic.cn/2017/09/29/TaxCalculator/&quot;&gt;Java Web 开发(一)：简易税务计算器&lt;/a&gt; 中，我尝试用最原生的 Java 语言（或者说 POJO）实现一个简单的 Http Server。由于项目时间的不足和当时对 Java 语言的不熟悉，最终写出了一个功能十分单一且简陋的 Server，而且充斥着各种 Bad Smelling 的代码。但是该项目也不是完全没有收获，在一次又一次的 Debug 中，我遇到了各种新手可能都会遇到的疑惑：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;单纯使用 POJO，会导致前端代码和后端代码高度耦合，且几乎没有很好的解耦手段。&lt;/li&gt;
  &lt;li&gt;难以实现功能全面的应用，主要原因是没有很好的依赖管理和存在大量的冗余代码。&lt;/li&gt;
  &lt;li&gt;做数据持久化时会遇到各种问题：不友好的数据库管理、拙劣的事务管理……&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;SSM 框架几乎完美解决了上面提到的问题&lt;/strong&gt;：Spring 通过 IoC 和 Bean 使得 POJO 也能低耦合地实现各种业务和服务功能；MyBatis 极大地降低了数据持久化的难度，通过 Mapper 机制简化了数据访问层（DAO）的开发；SprinMVC 则通过 controller 来处理用户请求和后台操作之间的关系，简化了 Web 层的开发；当然，使用 Maven 来进行依赖管理也让工程文件变得更加简洁明了。&lt;/p&gt;

&lt;p&gt;接下来，我会按步骤逐一地记录我配置 SSM 的过程，同时解释一些新手开发者可能有疑问的概念以及强调一些我自己掉入的坑。另外，我的配置很大程度上是对 &lt;a href=&quot;https://github.com/liyifeng1994/ssm&quot;&gt;Github - liyifeng1994/ssm&lt;/a&gt; 模仿练习，同时他的 README 也讲解地十分仔细，推荐给大家参考学习。&lt;/p&gt;

&lt;h3 id=&quot;二-ssm-框架结构&quot;&gt;(二) SSM 框架结构&lt;/h3&gt;

&lt;h4 id=&quot;创建-maven-项目&quot;&gt;创建 maven 项目&lt;/h4&gt;

&lt;p&gt;我是用的 IDE 是 IDEA，在 IDEA 中创建一个 maven 项目的步骤是：New Project — 选择 Maven — 选择合适的 JDK 版本 — 选择模板（此处略过此步）— New — 填写 GroupId 和 ArtifactId — 设置项目名称与路径 — Finish。&lt;/p&gt;

&lt;p&gt;在这里，我填写的 GroupId 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;cn.damonto&lt;/code&gt; ，ArtifactId 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssmTest&lt;/code&gt; ，项目名称默认与 ArtifactId 相同。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GroupId 和 ArtifactId 被统称为“坐标”，是为了保证项目唯一性而提出的。&lt;/p&gt;

  &lt;p&gt;GroupId 一般分为两段，第一段为域，第二段为公司名称。域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织。ArtifactId 一般与项目名称相同。&lt;/p&gt;

  &lt;p&gt;举个 apache 公司的 tomcat 项目例子：这个项目的 GroupId 是 org.apache，它的域是org，公司名称是apache，ArtifactId 是 tomcat。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;建立目录结构&quot;&gt;建立目录结构&lt;/h4&gt;

&lt;p&gt;在进行编码之前，先将一些文件夹提前建立，使得项目最终的目录结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssmTest
	|pom.xml			# maven配置文件
	|src				# 源代码
	  |test				# 测试文件
	  |main				
	    |java			# java文件
	    |resources		# xml等配置文件
	    	|mapper		# mybatis mapper配置文件
	    	|spring		# spring相关配置文件
	    |webapp			# Web层
	    |sql			# SQL文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 java 文件夹中创建必要的包，我将包的命名空间统一为 &lt;code class=&quot;highlighter-rouge&quot;&gt;cn.damonto.ssmTest&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java
  |cn
    |damonto
       |ssmTest
          |dao			# 数据访问层，Data Access Object
          |dto			# 数据传输层，Data Transfer Object
          |entity		# 实体类
          |service		# 业务逻辑
            |impl
          |web			# web controller
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;提前建立好文件夹与包是必要的，这让我们后续的开发更有条理。&lt;/p&gt;

&lt;h3 id=&quot;三-配置-pomxml&quot;&gt;(三) 配置 pom.xml&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt; 即为 maven 工程实现依赖管理的配置文件。在本项目中，除了必要的 Spring（包括核心库、Dao、test 等）、SpringMVC 和 MyBatis，还需要导入的依赖有：junit（单元测试）、mysql-connector-java（MySQL数据库连接）、c3p0（一个数据库连接池）、mybatis-spring（用于整合 Spring 与 MyBatis）……&lt;/p&gt;

&lt;p&gt;各个依赖的具体编码可以在 &lt;a href=&quot;https://mvnrepository.com/&quot;&gt;Maven Repository: Search/Browse/Explore&lt;/a&gt; 中查询得到。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;理论上，库应该不存在版本兼容的问题的。但是在这里 mybatis-spring 却出现了版本兼容的问题，使用 1.2.2 版本会出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()L&lt;/code&gt; 的错误。将版本改为 1.3.0 即可解决这个问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;pom.xml 的具体实现见：&lt;a href=&quot;https://github.com/DamonDu/ssmTest/blob/master/pom.xml&quot;&gt;pom.xml&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;四-配置-spring-与-mybatis&quot;&gt;(四) 配置 Spring 与 MyBatis&lt;/h3&gt;

&lt;h4 id=&quot;daospring-daoxml-与-mybatis-configxml&quot;&gt;DAO：spring-dao.xml 与 mybatis-config.xml&lt;/h4&gt;

&lt;p&gt;在 spring 文件夹中创建如下的 spring-dao.xml：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:context=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--jdbc相关参数--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:property-placeholder&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;location=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;classpath:jdbc.properties&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--配置c3p0连接池--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;driverClass&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${jdbc.driver}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdbcUrl&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${jdbc.url}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;user&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${jdbc.username}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${jdbc.password}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;maxPoolSize&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;30&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;minPoolSize&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;autoCommitOnClose&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;checkoutTimeout&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10000&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;acquireRetryAttempts&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--配置 mybatis 的 sqlSessionFactory--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sqlSessionFactory&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;configLocation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;classpath:mybatis-config.xml&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;typeAliasesPackage&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cn.damonto.ssmTest.entity&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mapperLocations&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;classpath:mapper/*.xml&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--配置扫描DAO包--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sqlSessionFactoryBeanName&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sqlSessionFactory&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;basePackage&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cn.damonto.ssmTest.dao&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;spring-dao.xml 配置数据访问层，主要包含四个方面的配置：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;从 jdbc.properties 中读取数据库相关参数。&lt;/strong&gt;在基于spring开发应用的时候，一般都会将数据库的配置放置在properties文件中。例如：&lt;/p&gt;

    &lt;div class=&quot;language-properties highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;py&quot;&gt;jdbc.driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;com.mysql.jdbc.Driver&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;jdbc.url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;amp;characterEncoding=utf8&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;jdbc.username&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;your_username&lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;jdbc.password&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;your_password&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;在 XML 中，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;property-placeholder&lt;/code&gt; 来将数据库配置读取并注入，在需要使用配置参数时，通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;${...}&lt;/code&gt; 来选取参数。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;关于 Spring 如何实现配置文件的加载，可以阅读 &lt;a href=&quot;https://www.cnblogs.com/leftthen/p/5615066.html&quot;&gt;Spring 中 property-placeholder 的使用与解析&lt;/a&gt; 进行了解。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;配置 c3p0 连接池。&lt;/strong&gt;c3p0 是一个开源的 JDBC 连接池，它实现了数据源和 JNDI 绑定，支持 JDBC3 规范和 JDBC2 的标准扩展。使用连接池可以方便我们对数据库连接进行管理，类似的连接池还有 DBCP、Proxool 、 BoneCP 等。&lt;/p&gt;

    &lt;p&gt;从线程的角度看，每创建一个数据库连接（Connection）其实都相当于创建了一个 ThreadLocal，所以连接池本质上也是一个线程池。在 &lt;a href=&quot;http://splitmusic.cn/2018/02/08/java-concurrency-learning-2/&quot;&gt;Java 并发学习笔记(二)：结构化并发应用程序&lt;/a&gt; 一文中，提到过通过公式计算一个最优的线程池大小，可以达到最大化的资源利用。同样，应该也可以使用相同的公式计算出一个最优的连接池大小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;配置 MyBatis-Spring。&lt;/strong&gt;要和 Spring 一起使用 MyBatis，我们需要在 Spring 应用上下文中定义至少两样东西:一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt; 和至少一个数据映射器类。同时，在这里我们需要&lt;strong&gt;在 resources 文件夹&lt;/strong&gt;创建MyBatis 的配置文件mybatis-config.xml，如下：&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;settings&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--开启主键自增--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;setting&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;useGeneratedKeys&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--开启列名别名--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;setting&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;useColumnLabel&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--开启驼峰命名转换--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;setting&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mapUnderscoreToCamelCase&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/settings&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;blockquote&gt;
      &lt;p&gt;需要注意的是”开启驼峰命名转换“。由于 SQL 的变量命名习惯是如同“book_id”的下划线分割形式，而 Java 字段命名一般则是如同“bookId”的驼峰式命名，所以需要开启驼峰命名转换以保证命名规则能互相对应。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;指定与扫描 Dao 包。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;servicespring-servicexml&quot;&gt;Service：spring-service.xml&lt;/h4&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:context=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:tx=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cn.damonto.ssmTest.service&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--注入数据库连接池--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManager&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--基于注解的声明式事务--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;tx:annotation-driven&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;transaction-manager=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManager&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;spring-service.xml 做了三件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开启对 service 包的扫描。&lt;/li&gt;
  &lt;li&gt;注入数据库连接池。&lt;/li&gt;
  &lt;li&gt;开启基于注解的声明式事务。之所以要使用基于注解的声明式事务，主要是为了方便 service 层的开发。事务方法往往是影响服务器性能的关键，使用注解来控制事务便于后期开发的解耦，避免其他层的代码混入事务方法中。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;在编写这个配置文件时我的一个小疑惑是： &lt;code class=&quot;highlighter-rouge&quot;&gt;dataSource&lt;/code&gt; 这个 bean reference 是不存在于本文件的上下文环境的，所以 IDE 会提示 Cannot resolve 的错误。在这里是可以忽视这个错误提示的，因为在后期运行时我们必然需要同时加载 spring-service.xml 和 spring-dao.xml，这样在运行时上下文就可以找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;dataSource&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;webspring-webxml-与-webxml&quot;&gt;Web：spring-web.xml 与 web.xml&lt;/h4&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:mvc=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:context=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://mybatis.org/schema/mybatis-spring&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cn.damonto.ssmTest.web&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--配置 Spring MVC--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:annotation-driven&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mvc:default-servlet-handler&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--配置 Spring MVC 视图解析器--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewClass&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.web.servlet.view.JstlView&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;prefix&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/WEB-INF/jsp&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;suffix&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.jsp&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;spring-web.xml 的内容就是简单的配置一下 SpringMVC 了，由于这次我没有想具体的实现 Web 层的东西，所以就只是简单的配置一下 servlet 和 ViewResolver，在这里也不做过多的深入探讨。&lt;/p&gt;

&lt;p&gt;在 webapp 文件夹建立如下的目录结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webapp
  |WEB-INF
     |jsp
     |web.xml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;web.xml 文件如下，配置了必要的 servlet 和 servlet-mapping：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;web-app&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3.1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;metadata-complete=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--配置 DispatcherServlet--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;ssmTest-dispatcher&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;classpath:spring/spring-*.xml&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;ssmTest-dispatcher&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此，一个最基本的 SSM 框架构建完毕。接下来通过一个简单的测试来检查 Spring 与 Mybatis 有没有正确配置。&lt;/p&gt;

&lt;h3 id=&quot;五-应用与测试&quot;&gt;(五) 应用与测试&lt;/h3&gt;

&lt;p&gt;在这里，我们通过一个简单的图书管理系统来测试我们的配置。&lt;/p&gt;

&lt;h4 id=&quot;测试准备&quot;&gt;测试准备&lt;/h4&gt;

&lt;p&gt;首先测试前要先写好最基本的实体类和接口类，实体类可以参考 &lt;a href=&quot;https://github.com/DamonDu/ssmTest/tree/master/src/main/java/cn/damonto/ssmTest/entity&quot;&gt;cn.damonto.ssmTest.entity&lt;/a&gt; ，Dao 接口类参考 &lt;a href=&quot;https://github.com/DamonDu/ssmTest/tree/master/src/main/java/cn/damonto/ssmTest/dao&quot;&gt;cn.damonto.ssmTest.dao&lt;/a&gt; 。我们只需要定义好 Dao 接口而不需要写具体实现，只要我们编写完对应的 mapper，Mybatis 会帮助我们动态地实现 Dao。&lt;/p&gt;

&lt;p&gt;例如 BookDao 对应的 mapper 配置文件 BookDao.xml 代码如下（位于 resources/mapper）：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;namespace=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cn.damonto.ssmTest.dao.BookDao&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

   &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;queryById&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Book&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
       SELECT *
       FROM book
       WHERE book_id = #{bookId}
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;queryAll&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Book&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        SELECT *
        FROM book
        ORDER BY book_id
        LIMIT #{offset}, #{limit}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;update&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;reduceNumber&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        UPDATE book
        SET book_number = book_number - 1
        WHERE book_id = #{bookId} AND book_number &amp;gt; 0
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/update&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AppointmentDao.xml 如下：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;namespace=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cn.damonto.ssmTest.dao.AppointmentDao&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;insert&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;insertAppointment&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        INSERT ignore INTO appointment (book_id, student_id)
        VALUE (#{bookId}, #{studentId})
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/insert&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;queryByKeyWithBook&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Appointment&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        SELECT a.book_id, a.student_id, a.appointment_time,
          b.book_id &quot;book.book_id&quot;, b.book_name &quot;book.book_name&quot;, b.book_number &quot;book.book_number&quot;
        FROM appointment a
        INNER  JOIN book b ON a.book_id = b.book_id
        WHERE a.book_id = #{bookId} AND a.student_id = #{studentId}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到 Mybatis 让我们在 XML 中用与 SQL 语法相似的形式来进行 SQL 操作，并且将 DAO 层的代码很好地解耦，对于我们 SQL 操作的编写和 Debug 都十分方便。&lt;/p&gt;

&lt;p&gt;当然，在测试前还需要先在数据库中建好对应的 Table 并插入一些样例数据作测试，SQL 参考如下：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BOOK&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;book_id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auto_increment&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'图书ID'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;book_name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'图书名称'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;book_number&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'图书数量'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;innodb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auto_increment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BOOK&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;book_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;book_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'bookA'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'bookB'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1002&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'bookC'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1003&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'bookD'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;APPOINTMENT&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;book_id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'图书ID'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;student_id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bigint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'学生ID'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;appointment_time&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;current_timestamp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;current_timestamp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'预约时间'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx_atime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appointment_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;innodb&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;编写测试文件&quot;&gt;编写测试文件&lt;/h4&gt;

&lt;p&gt;在 test/java 文件夹中建立与 src/java 文件夹的包结构，并且在对应的路径下编写测试文件。&lt;/p&gt;

&lt;p&gt;首先先写测试基类 BaseTest.java ，在这里我们加载了 spring-dao.xml 和 spring-service.xml，由于不进行 web 层的开发所以不需要 spring-web.xml：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;damonto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ssmTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.junit.runner.RunWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.test.context.ContextConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.test.context.junit4.SpringJUnit4ClassRunner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@RunWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SpringJUnit4ClassRunner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ContextConfiguration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;classpath:spring/spring-dao.xml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;classpath:spring/spring-service.xml&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BaseTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着，我们以测试 BookDao 为例：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;damonto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ssmTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dao&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;cn.damonto.ssmTest.BaseTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;cn.damonto.ssmTest.entity.Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.junit.Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.springframework.beans.factory.annotation.Autowired&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BookDaoTest&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BaseTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BookDao&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookDao&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testQueryById&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;book&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookDao&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;queryById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bookId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testQueryAll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;books&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookDao&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;queryAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;book&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;books&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testReduceNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bookDao&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reduceNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bookId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Update = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于 BookDao 的实现是有 MyBatis 在运行时才进行的，所以编译时会发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;bookDao&lt;/code&gt; 的 bean 装载会提示错误，这个错误同样是可以忽视的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这里就不做严谨的断言测试了，直接通过控制台输出测试，若无异常应有如下的输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Book [book id = 1000, book name = bookA, books number = 10]
Book [book id = 1000, book name = bookA, books number = 10]
Book [book id = 1001, book name = bookB, books number = 10]
Book [book id = 1002, book name = bookC, books number = 10]
Book [book id = 1003, book name = bookD, books number = 10]
Update = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于 AppointmentDao 也采取相似的测试，若同样无异常，则证明 SSM 框架配置成功。&lt;/p&gt;

&lt;h3 id=&quot;六-总结&quot;&gt;(六) 总结&lt;/h3&gt;

&lt;p&gt;SSM 框架和 SSH 框架几乎可以适用于所有场景的 Java Web 开发，并且可以极大地提高开发效率和提升代码质量。但是还是存在一些问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Spring 和 SpringMVC 过度地依赖 XML 进行配置，虽然已经很大简化了配置但随着项目的复杂必然还是会让配置文件越来越臃肿，不符合现在追求轻量级框架的需求。所以，新兴的更加轻量级 SpringBoot 必然会在未来取代大多数 SpringMVC 的工作。&lt;/li&gt;
  &lt;li&gt;随着服务器流量和并发访问的增加，简单的 SSM 框架肯定是无法满足需求的。并且对于特定用途的服务器（例如需要高响应的游戏服务器），SSM 也是无法很好的工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;参考网站：&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;Github - liyifeng1994/ssm：&lt;a href=&quot;https://github.com/liyifeng1994/ssm&quot;&gt;https://github.com/liyifeng1994/ssm&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Spring 中 property-placeholder 的使用与解析：&lt;a href=&quot;https://www.cnblogs.com/leftthen/p/5615066.html&quot;&gt;https://www.cnblogs.com/leftthen/p/5615066.html&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;mybatis-spring document：&lt;a href=&quot;http://www.mybatis.org/spring/zh/&quot;&gt;http://www.mybatis.org/spring/zh/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Ant风格路径表达式详解：&lt;a href=&quot;http://www.bug315.com/article/131.htm&quot;&gt;http://www.bug315.com/article/131.htm&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;c3p0数据库连接池的使用详解：&lt;a href=&quot;https://www.cnblogs.com/fingerboy/p/5184398.html&quot;&gt;https://www.cnblogs.com/fingerboy/p/5184398.html&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 05:00:00 +0800</pubDate>
        <link>https://damondu.github.io//2018/03/03/java-web-2/</link>
        <guid isPermaLink="true">https://damondu.github.io//2018/03/03/java-web-2/</guid>
        
        <category>Java</category>
        
        <category>Java Web</category>
        
        <category>Spring</category>
        
        
      </item>
    
      <item>
        <title>JDK 源码阅读(一)：理解 ThreadLocal</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;ThreadLocal 是 Java 并发领域里一个十分重要的类，本文将深入 ThreadLocal 这个类的具体含义与细节实现（基于 JDK8）。如果你之前没有接触或使用过 ThreadLocal ，那么推荐你先简单了解一下 ThreadLocal 的使用（推荐 @vigarbuaa 的 &lt;a href=&quot;http://www.cnblogs.com/vigarbuaa/archive/2012/03/01/2375149.html&quot;&gt;Java ThreadLocal示例及使用方法总结&lt;/a&gt; 这篇博客），以及你需要了解一些关于 Java 并发的基础知识（推荐我的 &lt;a href=&quot;http://splitmusic.cn/2018/02/05/java-concurrency-learning-1/&quot;&gt;Java 并发学习笔记 (一)：并发基础知识&lt;/a&gt; 一文）。希望本文对你有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;一-threadlocal-的定义与作用&quot;&gt;(一) ThreadLocal 的定义与作用&lt;/h3&gt;

&lt;p&gt;学习 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 之前，最好明晰它处于 Java 开发体系的什么位置。&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 类定义在 java / lang 中，但是其主要的应用是在于并发领域。&lt;a href=&quot;https://book.douban.com/subject/10484692/&quot;&gt;《 Java 并发编程实战》&lt;/a&gt;中提到：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;处理线程安全性问题的三种主要方式：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;不在线程之间共享该状态变量&lt;/li&gt;
    &lt;li&gt;将状态变量设置为不可变&lt;/li&gt;
    &lt;li&gt;在访问状态变量时使用同步&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 在应该被归类于第一类技术：即通过&lt;strong&gt;线程封闭（Thread Confinement）&lt;/strong&gt;技术，使得状态变量与特定的线程”绑定“起来（不在线程之间共享该状态变量），从而保证在多线程下的线程安全性。&lt;a href=&quot;https://book.douban.com/subject/10484692/&quot;&gt;《 Java 并发编程实战》&lt;/a&gt;将线程封闭技术分为三种：Ad-hoc 线程封闭、栈封闭以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 。其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 是由 JDK 提供的、最易实现和维护且最为健壮的线程封闭技术。（具体请看 &lt;a href=&quot;http://splitmusic.cn/2018/02/05/java-concurrency-learning-1/&quot;&gt;Java 并发学习笔记 (一)：并发基础知识&lt;/a&gt; 一文）&lt;/p&gt;

&lt;h3 id=&quot;二-对-threadlocal-的整体了解与实现猜想&quot;&gt;(二) 对 ThreadLocal 的整体了解与实现猜想&lt;/h3&gt;

&lt;p&gt;在了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的具体实现之前，我们可以先通过对 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 源码结构的总体把握来大概了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 实现线程封闭的基本原理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/ThreadLocal-structure.jpg&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的作者在注释中如此介绍  &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的工作原理：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable.  {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大概告诉了我们几点信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 为线程提供了一种特殊的”线程内部变量“（thread-local variables）。&lt;/li&gt;
  &lt;li&gt;线程通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 方法来获取一个变量副本，这个变量副本为该线程所独有。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 实例最好是一个 private static 修饰的字段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结合上面 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;  的结构中，有一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 的内部类，&lt;strong&gt;我们可以大胆地对 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的实现进行如下猜想：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 维护一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 的 key 为每个线程的 ThreadId，value 为我们需要封闭的线程内部变量。每次调用其 &lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; ，以当前线程的 ThreadId 为 key 从  &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 中定位到其对应的线程内部变量，从而实现不同线程之间的隔离。&lt;/p&gt;

&lt;p&gt;这种想法十分直接，事实上 JDK 早期的版本也是如此进行实现的，但是&lt;strong&gt;这种实现方法现在已经被摒弃&lt;/strong&gt;。以下，我们尝试通过阅读 jdk8 源码中 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的实现来了解这种实现方式为何被摒弃。&lt;/p&gt;

&lt;h3 id=&quot;三-threadlocal-的实现细节&quot;&gt;(三) ThreadLocal 的实现细节&lt;/h3&gt;

&lt;h4 id=&quot;threadthreadlocalthreadlocalmap-的关系&quot;&gt;Thread、ThreadLocal、ThreadLocalMap 的关系&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的一般使用步骤为：new 一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; ，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 方法设置线程内部变量，需要变量时调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt; 方法获取变量。那么我们就根据这个使用步骤来看看此时 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;  内部的运作。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* Creates a thread local variable.
* @see #withInitial(java.util.function.Supplier)
*/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 只是简单的创建实例，没有做额外的初始化操作。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* Sets the current thread's copy of this thread-local variable
* to the specified value.  Most subclasses will have no need to
* override this method, relying solely on the {@link #initialValue}
* method to set the values of thread-locals.
*
* @param value the value to be stored in the current thread's copy of
*        this thread-local.
*/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 获取当前线程&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 获取当前线程所维护的 ThreadLocalMap&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ThreadLocalMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// map 非空则取对象&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
       	&lt;span class=&quot;c1&quot;&gt;// map 为空则创建 map 并进行相应的初始化&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;createMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 方法的实现中我们已经可以看到这和我们之前的猜想不尽相同。在 JDK8 中， &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的基本实现思路是：每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt; 维护一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 实例， &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 的 key 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 实例，value 是线程内部变量。访问线程内部变量时，先获取当前线程对应的  &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; ，再在该 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt;  中获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 对应的内部变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这种实现方式有何优点呢？&lt;/strong&gt; 最大的优点应该是：当线程结束时， &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 也会随之销毁，以避免对内存的占用。&lt;/p&gt;

&lt;p&gt;上述代码除了说明了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的基本实现，还说明了一个细节：每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt; 所对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 是有可能为空的，也就是说线程不会在创建时就直接创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 并与之绑定，而是&lt;strong&gt;采取 JIT 策略，在需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 之前才绑定。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;threadlocalmap-的创建&quot;&gt;ThreadLocalMap 的创建&lt;/h4&gt;

&lt;p&gt;这里继续看 &lt;code class=&quot;highlighter-rouge&quot;&gt;createMap()&lt;/code&gt; 的具体实现和 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 的创建。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* Create the map associated with a ThreadLocal. Overridden in
* InheritableThreadLocal.
*
* @param t the current thread
* @param firstValue value for the initial entry of the map
*/&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 调用 ThreadLocalMap 的构造函数&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;threadLocals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadLocalMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadLocalMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;//...省略了部分无关代码&lt;/span&gt;
    
    &lt;span class=&quot;cm&quot;&gt;/**
    * Construct a new map initially containing (firstKey, firstValue).
    * ThreadLocalMaps are constructed lazily, so we only create
    * one when we have at least one entry to put in it.
    */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ThreadLocalMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// map 的内部实际为一个 Entry 类型的数组，常量 INITIAL_CAPACITY 默认为 16&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL_CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// threadLocalHashCode 是优化后的哈希散列值，减少了碰撞的发生；&amp;amp;运算使得 i 落在 0~15 之间&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;threadLocalHashCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL_CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;setThreshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL_CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;cm&quot;&gt;/**
         * Set the resize threshold to maintain at worst a 2/3 load factor.
         */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setThreshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;读到这里，我们会有两个疑问：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threadLocalHashCode&lt;/code&gt; 是什么？它对哈希表进行了哪些优化？&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; 大于 &lt;code class=&quot;highlighter-rouge&quot;&gt;threshold&lt;/code&gt; 时，如何处理？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来的两部分我们分别关注这里提出的两个问题。&lt;/p&gt;

&lt;h4 id=&quot;threadlocalhashcode-对哈希表进行的优化&quot;&gt;threadLocalHashCode 对哈希表进行的优化&lt;/h4&gt;

&lt;p&gt;我们看回 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
     * ThreadLocals rely on per-thread linear-probe hash maps attached
     * to each thread (Thread.threadLocals and
     * inheritableThreadLocals).  The ThreadLocal objects act as keys,
     * searched via threadLocalHashCode.  This is a custom hash code
     * (useful only within ThreadLocalMaps) that eliminates collisions
     * in the common case where consecutively constructed ThreadLocals
     * are used by the same threads, while remaining well-behaved in
     * less common cases.
     */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadLocalHashCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextHashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
     * The next hash code to be given out. Updated atomically. Starts at
     * zero.
     */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AtomicInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextHashCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AtomicInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
     * The difference between successively generated hash codes - turns
     * implicit sequential thread-local IDs into near-optimally spread
     * multiplicative hash values for power-of-two-sized tables.
     */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HASH_INCREMENT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x61c88647&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
     * Returns the next hash code.
     */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;nextHashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextHashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAndAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HASH_INCREMENT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threadLocalHashCode&lt;/code&gt; 以 &lt;code class=&quot;highlighter-rouge&quot;&gt;HASH_INCREMENT&lt;/code&gt; 为增量，产生一组从 0、1 * HASH_INCREMENT、2 * HASH_INCREMENT…到 n * HASH_INCREMENT 的哈希散列值。在这里，HASH_INCREMENT 被设置为一个很特殊的十六进制数——「0x61c88647」。以这个数形成的散列称为斐波那契散列（Fibonacci Hashing）。斐波那契散列使得哈希表分布更加均匀，极大地减少了碰撞的发生，在实际运用中往往对效率有很大的提升。&lt;/p&gt;

&lt;h4 id=&quot;threadlocalmap-的扩容&quot;&gt;ThreadLocalMap 的扩容&lt;/h4&gt;

&lt;p&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; 大于 &lt;code class=&quot;highlighter-rouge&quot;&gt;threshold&lt;/code&gt; 时，最基本的想法是直接对 table 进行扩容，一般的做法就是 new 一个两倍大小的 table 并将原 table deep copy 到新的 table，&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt;  提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt; 方法：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
         * Double the capacity of the table.
         */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldLen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newLen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldLen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newLen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// deep copy&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldLen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Help the GC&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;threadLocalHashCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newLen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newLen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;setThreshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newLen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然而，更关键的问题在于：进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt; 的条件是什么？&lt;/p&gt;

&lt;p&gt;相比每次一达到 &lt;code class=&quot;highlighter-rouge&quot;&gt;threshold&lt;/code&gt; 就进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt; ，如果我们对 &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt; 的条件加以限制，尽可能地减少 &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt; 的次数，则可以尽可能地优化性能。所以我们不妨看看 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 是如何对这一条件进行限制的。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
         * Set the value associated with key.
         *
         * @param key the thread local object
         * @param value the value to be set
         */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// We don't use a fast path as with get() because it is at&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// least as common to use set() to create new entries as&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// it is to replace existing ones, in which case, a fast&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// path would fail more often than not.&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;threadLocalHashCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 发生哈希碰撞，则储存在下一个 entry 中&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;replaceStaleEntry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 需要满足 cleanSomeSlots(i, sz) 为 fales 且 sz &amp;gt;= threshold 才进行 rehash()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cleanSomeSlots&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// rehash() 方法调用了 resize()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rehash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cleanSomeSlots(i, n)&lt;/code&gt; 的主要作用是在哈希表中找到过期的项（stale entry）并将其擦除，以避免表空间被这些过期的项占用。stale entry 的产生很自然，当我们所保护的线程内部变量使用完毕，生命周期结束后则会被 GC 掉，这些 value 已被清除的 entry 则为 stale entry。&lt;/p&gt;

&lt;p&gt;需要注意的是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanSomeSlots()&lt;/code&gt; 的实现（如下代码）中，出于对性能和时间复杂度的平衡， &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanSomeSlots()&lt;/code&gt; 并不是扫描 n 个 entry，而是扫描 log2(n) 个。虽然无法找出所有的 stale entry，但将时间复杂度从O(n) 降为 O(log2(n))。在实践中，这种平衡策略能提高效率，而且往往是够用的。&lt;/p&gt;

&lt;p&gt;另外，当 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 调用  &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanSomeSlots()&lt;/code&gt;  时，参数 n 传入的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; （即 entry 的个数）；如果在扫描过程中找到了 stale entry，n 的值会被 &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanSomeSlots()&lt;/code&gt; 为修改为 &lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt; （即 table 的总容量），即此时 &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanSomeSlots()&lt;/code&gt; 的扫描范围被扩大为整个表。采取这种实现的原因代码作者没有在注释中解释，但是从我的角度理解：这是一种从统计角度的优化。从 JVM 执行 GC 的角度来看，当 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 中发现了一个项因被 GC 而过期，那么此时往往存在多个项也是过期的，所以在此时扩大扫描范围，有更大的概率找到更多的 stale entry ，从而提高 &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanSomeSlots()&lt;/code&gt; 的效率。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
         * Heuristically scan some cells looking for stale entries.
         * This is invoked when either a new element is added, or
         * another stale one has been expunged. It performs a
         * logarithmic number of scans, as a balance between no
         * scanning (fast but retains garbage) and a number of scans
         * proportional to number of elements, that would find all
         * garbage but would cause some insertions to take O(n) time.
         *
         * @param i a position known NOT to hold a stale entry. The
         * scan starts at the element after i.
         *
         * @param n scan control: {@code log2(n)} cells are scanned,
         * unless a stale entry is found, in which case
         * {@code log2(table.length)-1} additional cells are scanned.
         * When called from insertions, this parameter is the number
         * of elements, but when from replaceStaleEntry, it is the
         * table length. (Note: all this could be changed to be either
         * more or less aggressive by weighting n instead of just
         * using straight log n. But this version is simple, fast, and
         * seems to work well.)
         *
         * @return true if any stale entries have been removed.
         */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cleanSomeSlots&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 符合该 if 条件的则为 stale entry，将其擦除&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;removed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expungeStaleEntry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 无符号右移一位并赋值，所以最终循环 log2(n) 次&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除了在 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 限制进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt; 的条件，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;rehash()&lt;/code&gt; 调用  &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt; 过程中， &lt;code class=&quot;highlighter-rouge&quot;&gt;rehash()&lt;/code&gt; 又做了进一步地限制：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
         * Re-pack and/or re-size the table. First scan the entire
         * table removing stale entries. If this doesn't sufficiently
         * shrink the size of the table, double the table size.
         */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rehash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// expunge all stale entry&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expungeStaleEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Use lower threshold for doubling to avoid hysteresis&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rehash()&lt;/code&gt; 进行限制的原理与 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 的实现异曲同工，但扫描程度更完全。之前说过 &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanSomeSlots()&lt;/code&gt; 只会扫描范围内的 log2(n) 个 entry，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;expungeStaleEntries()&lt;/code&gt; 会扫描范围内所有的 entry。&lt;strong&gt;总之，&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 通过种种手段，保证了只有当哈希表中完全没有过期的项时才有可能进行扩容。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;总结-threadlocal-的实现&quot;&gt;总结 ThreadLocal 的实现&lt;/h4&gt;

&lt;p&gt;至此，我们从 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreadLocal.set()&lt;/code&gt; 开始，了解了 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreadLocalMap()&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;TreadLocalMap.set()&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanSomeSlots()&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;expungeStaleEntries()&lt;/code&gt;  ，基本理清了从创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 到进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 时 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的内部实现，包括了：Thread、TreadLocal、TreadLocalMap 三者的关系；TreadLocalMap 的创建；TreadLocalMap 为减少碰撞对哈希表的优化；TreadLocalMap 的扩容和对应的优化。&lt;/p&gt;

&lt;p&gt;至于 &lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt; 的理解相信在理解了 &lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt; 之后就相对比较简单，所以这里就不再赘述。&lt;/p&gt;

&lt;p&gt;###(四) ThreadLocal 会导致内存泄漏？&lt;/p&gt;

&lt;p&gt;有一些观点认为，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 可能会导致内存泄漏，原因基于以下的事实：&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 的实现中， &lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt; 继承了 &lt;code class=&quot;highlighter-rouge&quot;&gt;WeakReference&lt;/code&gt;（即弱引用），如下：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as &quot;stale entries&quot; in the code that follows.
         */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WeakReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用实线代表强引用，虚线代表弱引用，那么使用 ThreadLocal 时对象在 JVM 内存中如下分布：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/ThreadLocal-WeakRef.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设强引用不存在了，那么 GC 时 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 对象由于只有弱引用所以会被回收，那么 key 就会变为 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; ，意味着其对应的 value 将永远无法被调用到，导致内存泄漏。然而 JDK 设计者也意识到这个问题，所以也采取了一定的措施避免这种问题出现。例如在 &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt; 中有这样一段代码：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Help the GC&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类似的代码不止一处，其实在 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 中，只要涉及到扫描 Entry 的方法，都会检查其 key 是否为空，如若为空都会及时清除 value 以避免内存泄漏。类似的代码几乎遍布于 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt; 的方法实现之中（感兴趣的可以找来源码看看有多少方法加入了类似的代码）。所以说，内存泄漏在实际使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 时虽有可能出现，但我们也不用对此过于担心。同时，为了最大化的保证安全性，我们也可以在调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt; 来保证当前线程的所有内部变量都被销毁。&lt;/p&gt;

&lt;h3 id=&quot;五-总结&quot;&gt;(五) 总结&lt;/h3&gt;

&lt;p&gt;了解完 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的实现，其实我们发现：本质上， &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 类是通过 OOP 的封装思想，实现了变量的线程封闭。虽然思想是简单直接的，但是具体实现中却是有很多细节上的心思：例如 Thread、ThreadLocal、ThreadLocalMap 三个类关系的处理，例如对扩容操作的逐步限制以优化性能，例如对内存泄漏的避免….这些都很值得我们在实际开发中学习与借鉴。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;参考资料：&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;JAVA 并发 - 自问自答学 ThreadLocal：&lt;a href=&quot;https://juejin.im/post/5a0e985df265da430e4ebb92&quot;&gt;https://juejin.im/post/5a0e985df265da430e4ebb92&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ThreadLocal源码分析解密  - By 谢照东：&lt;a href=&quot;http://xiezhaodong.me/2016/03/05/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%A7%A3%E5%AF%86/&quot;&gt;http://xiezhaodong.me/2016/03/05/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%A7%A3%E5%AF%86/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;ThreadLocal和 synchronized的区别 ? - 知乎用户的回答 - 知乎：&lt;a href=&quot;https://www.zhihu.com/question/23089780/answer/62097840&quot;&gt;https://www.zhihu.com/question/23089780/answer/62097840&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Java ThreadLocal 示例及使用方法总结：&lt;a href=&quot;http://www.cnblogs.com/vigarbuaa/archive/2012/03/01/2375149.html&quot;&gt;http://www.cnblogs.com/vigarbuaa/archive/2012/03/01/2375149.html&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Github - lambdalab-mirror/jdk8u-jdk：&lt;a href=&quot;https://github.com/lambdalab-mirror/jdk8u-jdk/&quot;&gt;https://github.com/lambdalab-mirror/jdk8u-jdk/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 26 Feb 2018 06:40:00 +0800</pubDate>
        <link>https://damondu.github.io//2018/02/26/jdk-reading-1/</link>
        <guid isPermaLink="true">https://damondu.github.io//2018/02/26/jdk-reading-1/</guid>
        
        <category>Java</category>
        
        <category>JDK</category>
        
        <category>ThreadLocal</category>
        
        <category>Concurrency</category>
        
        
      </item>
    
      <item>
        <title> Java 并发学习笔记(四)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这是我阅读&lt;a href=&quot;https://book.douban.com/subject/10484692/&quot;&gt;《 Java 并发编程实战》&lt;/a&gt;整理出的知识大纲，第四部分主要是关于 Java 并发的高级内容，主要包括：显示锁、条件队列、AQS、原子变量、非阻塞算法以及 JVM 中关于并发的一些底层细节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;before-reading&quot;&gt;Before Reading&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;本篇文章对应原书 13~16 章的内容。&lt;/li&gt;
  &lt;li&gt;建议通读过原书的对应内容后再使用这份知识大纲。&lt;/li&gt;
  &lt;li&gt;大部分内容为原书的摘抄，少部分是我自己的归纳。&lt;/li&gt;
  &lt;li&gt;文章中的代码是从原书 example 中摘抄得来，你可以从&lt;a href=&quot;http://jcip.net/listings.html&quot;&gt;原书官网&lt;/a&gt;获取完整的代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;显式锁&quot;&gt;显式锁&lt;/h3&gt;

&lt;h4 id=&quot;lock-与-reentrantlock&quot;&gt;Lock 与 ReentrantLock&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt; 提供了一种&lt;strong&gt;无条件的&lt;/strong&gt;、&lt;strong&gt;可轮询的&lt;/strong&gt;、&lt;strong&gt;定时的&lt;/strong&gt;以及&lt;strong&gt;可中断的&lt;/strong&gt;锁获取操作，所有加锁和解锁的方法都是&lt;strong&gt;显式的&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt; 接口，提供了与 &lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 相同的&lt;strong&gt;互斥性和内存可见性&lt;/strong&gt; ；提供了可重入的加锁语义；支持在Lock接口中定义的所有获取锁模式；为处理锁的不可用性问题提供了更高的灵活性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;为什么要创建一种与内置锁如此相似的新加锁机制？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;内置锁无法中断一个正在等待获取锁的线程。&lt;/li&gt;
      &lt;li&gt;内置锁无法在请求获取一个锁时无限地等待下去。&lt;/li&gt;
      &lt;li&gt;内置锁无法实现非阻塞结构的加锁规则。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt; 加锁之后不会自动释放锁，必须在 &lt;code class=&quot;highlighter-rouge&quot;&gt;finally&lt;/code&gt; 块中释放锁。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;可定时的与可轮询的锁获取模式是由 &lt;code class=&quot;highlighter-rouge&quot;&gt;tryLock&lt;/code&gt; 方法实现的，它具有更完善的错误恢复机制，可以用于：避免死锁的发生；实现具有时间限制的操作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;locklnterruptibly&lt;/code&gt; 方法能够在获得锁的同时保持对中断的响应。&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 的构造函数中提供了&lt;strong&gt;两种公平性选择&lt;/strong&gt;：非公平的锁（默认）或
公平的锁。
    &lt;ul&gt;
      &lt;li&gt;在公平的锁上，线程将按照它们发出请求的顺序来获得锁。&lt;/li&gt;
      &lt;li&gt;非公平的锁上，则&lt;strong&gt;允许“插队”&lt;/strong&gt;：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;公平性&quot;&gt;公平性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;公平性 VS 非公平性&lt;/strong&gt;：公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能。但在实际情况中，确保被阻塞的线程能最终获得锁（也就是&lt;strong&gt;非公平&lt;/strong&gt;，或者说是&lt;strong&gt;统计上的公平保证&lt;/strong&gt;）通常已经够用了，并且实际开销也小得多。&lt;/li&gt;
  &lt;li&gt;激烈竞争下，&lt;strong&gt;非公平锁的性能高于公平锁的性能的一个原因是&lt;/strong&gt;：在恢复一个被挂
起的线程与该线程真正开始运行之间存在着严重的延迟。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;应该优先使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;&lt;/strong&gt; ：使用内置锁，代码更加简洁紧凑，而且更不容易出错。所以应把 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReentrantLock&lt;/code&gt; 作为一种高级工具，在需要一些高级功能时才使用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;互斥通常是一种过于强硬的加锁规则&lt;/strong&gt;，虽然可以避免“写/写”冲突和“写/读”冲突，但同样也避免了“读/读”冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;读写锁&quot;&gt;读/写锁&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;读/写锁&lt;/strong&gt;：一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;读/写锁 VS 互斥锁&lt;/strong&gt;：对于在多处理器系统上被频繁读取的数据结构，读/写锁能够提高性能。而在其他情况下，读/写锁的性能比互斥锁的性能要略差一些：这是因为它们的复杂性更高。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReadWriteLock&lt;/code&gt; 中的一些可选实现：释放优先；读线程插队；重入性；降级；升级。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在非公平的锁中&lt;/strong&gt;，线程获得访问许可的顺序是不确定的。写线程降级为读线程是可以的，但&lt;strong&gt;从读线程升级为写线程则是不可以的&lt;/strong&gt;（这样做会导致死锁）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;构建自定义的同步工具&quot;&gt;构建自定义的同步工具&lt;/h3&gt;

&lt;h4 id=&quot;状态依赖性的管理&quot;&gt;状态依赖性的管理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;依赖状态的操作可以一直阻塞直到可以继续执行，这比使它们先失败再实现起来要更为方便且更不易出错。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;处理前提条件失败的方法&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;将前提条件的失败传递给调用者&lt;/strong&gt;：实现简单，但使用复杂，调用者必须做好捕获异常的准备。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;通过轮询和休眠来实现简单的阻塞&lt;/strong&gt;：将前提条件的管理操作封装起来，使调用者无须在每次调用时都实现重试逻辑。但对调用者提出了一个新的需求：处理 &lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;使用条件队列&lt;/strong&gt;：使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真。与使用“休眠”相比，条件队列并没有改变原来的语义。它只是在多个方面进行了优化：CPU效率、上下文切换开销和响应性等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每个对象可以作为一个条件队列&lt;/strong&gt;，并且 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAII&lt;/code&gt; 方法就构成了内部条件队列的 API。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.wait&lt;/code&gt; 会&lt;strong&gt;自动释放锁&lt;/strong&gt;，并请求操作系统挂起当前线程，从而使其他线程能够获得这个锁并修改对象韵状态。当被挂起的线程醒来时，它将在&lt;strong&gt;返回之前重新获取锁&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用条件队列&quot;&gt;使用条件队列&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;条件谓词&lt;/strong&gt;：条件谓词是使某个操作成为状态依赖操作的前提条件。要想正确地使用条件队列，关键是找出对象在哪个条件谓词上等待。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;锁对象和条件队列对象必须是同一个对象。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 调用都会隐式地与特定的条件谓词关联起来。&lt;/strong&gt;当调用某个特定条件谓词的 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 时，调用者必须已经持有与条件队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 方法的返回并不一定意味着线程正在等待的条件谓词已经变成真了。所以，每当线程从 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 中唤醒时，都&lt;strong&gt;必须再次测试条件谓词&lt;/strong&gt;，如果条件谓词不为真，那么就继续等待（或者失败）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;总结：当使用条件等待时&lt;/strong&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.wait&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;Condition.await&lt;/code&gt;）
    &lt;ul&gt;
      &lt;li&gt;通常都有一个条件谓词：包括一些对象状态的测试，线程在执行之前必须首先通过这些测试。&lt;/li&gt;
      &lt;li&gt;在调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 之间测试条件谓词，并且从 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 中返回时再次测试。&lt;/li&gt;
      &lt;li&gt;在一个循环中调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt;。&lt;/li&gt;
      &lt;li&gt;确保使用与条件队列相关的锁来保护构成条件谓词的各个状态变量。&lt;/li&gt;
      &lt;li&gt;当调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll&lt;/code&gt; 等方法时，一定要持有与条件队列相关的锁。&lt;/li&gt;
      &lt;li&gt;在检查条件谓词之后以及开始执行相应的操作之前，不要释放锁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;丢失的信号&lt;/strong&gt;：线程必须等待一个已经为真的条件，但在开始等待之前没有检查条件谓词。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通知&lt;/strong&gt;：每当在等待一个条件时，一定要确保在条件谓词变成真时通过某种方式发出通知。
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt; ：从这个条件队列上等待的多个线程中选择一个来唤醒。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAII&lt;/code&gt; ：会唤醒所有在这个条件队列上等待的线程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;发出通知的线程应该尽快地释放锁&lt;/strong&gt;：如果这些等待中线程此时不能重新获得锁，那么无法从 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 返回，因此发出通知的线程应该尽快地释放锁，从而确保正在等待的线程尽可能快地解除阻塞。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;应该优先选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll&lt;/code&gt; 而不是单个的 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt;&lt;/strong&gt; ：单一的通知很容易导致类似于信号丢失的问题。
    &lt;ul&gt;
      &lt;li&gt;只有同时满足：所有等待线程的类型都相同（同个条件谓词）、单进单出这两个条件时，才应该使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;当只有一个线程可以执行时，如果使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll&lt;/code&gt; ，那么将是低效的。&lt;/strong&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll&lt;/code&gt; 将唤醒每个线程，并使得它们在锁上发生竞争，然后，它们中的大多数或者全部又都回到休眠状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;条件通知（Conditional Notification）&lt;/strong&gt;：仅当操作影响到状态转换时，才发出通知，这也被称为条件通知。条件通知可以提升性能，但很难实现。&lt;/li&gt;
  &lt;li&gt;在使用条件通知或单次通知时，一些&lt;strong&gt;约束条件使得子类化过程变得更加复杂&lt;/strong&gt;。两个设计类时的解决方法是：
    &lt;ol&gt;
      &lt;li&gt;将其等待和通知等协议完全向子类公开（并且写入正式文档）：例如公开条件队列和锁、条件谓词和同步策略、一些底层的状态变量。&lt;/li&gt;
      &lt;li&gt;禁止子类化。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;通常，我们应该把条件队列封装起来，但这与“使用对象的内置锁来保护对象自身的状态”冲突。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;入口协议和出口协议（Entry and Exit Protocols）&lt;/strong&gt;：描述 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify&lt;/code&gt; 方法的正确使用。
    &lt;ul&gt;
      &lt;li&gt;入口协议就是该操作的条件谓词。&lt;/li&gt;
      &lt;li&gt;出口协议则包括，检查被该操作修改的所有状态变量，并确认它们是否使某个其他的条件谓词变为真，如果是，则通知相关的条件队列。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Condition&lt;/code&gt; ：一种&lt;strong&gt;广义的&lt;/strong&gt;内置条件队列。
    &lt;ul&gt;
      &lt;li&gt;内置条件队列存在一些缺陷，每个内置锁都只能有一个相关联的条件队列。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Condition&lt;/code&gt; 更加灵活：在每个锁上可存在多个等待、条件等待可以是可中断的或不可中断的、基于时限的等待，以及公平的或非公平的队列操作。&lt;/li&gt;
      &lt;li&gt;创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Condition&lt;/code&gt; ，可以在相关联的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt; 上调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Lock.newCondition&lt;/code&gt; 方法。&lt;/li&gt;
      &lt;li&gt;如果需要一些高级功能，那么应该优先使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Condition&lt;/code&gt; 而不是内置条件队列。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AbstractQueuedSynchronizer(AQS)&lt;/strong&gt; ：AQS 是一个用于构建锁和同步器的框架，许多同步器都可以通过 AQS 很容易并且高效地构造出来。
    &lt;ul&gt;
      &lt;li&gt;AQS 负责管理同步器类中的状态，它管理了一个整数状态信息，可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;getState&lt;/code&gt; ，&lt;code class=&quot;highlighter-rouge&quot;&gt;setState&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;compareAndSetState&lt;/code&gt; 等 &lt;code class=&quot;highlighter-rouge&quot;&gt;protected&lt;/code&gt; 类型方法来进行操作。&lt;/li&gt;
      &lt;li&gt;提供了最基本的获取操作和释放操作，可选地支持独占或共享的获取操作。&lt;/li&gt;
      &lt;li&gt;提供了一些机制来构造与同步器相关联的条件变量。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;原子变量与非阻塞同步机制&quot;&gt;原子变量与非阻塞同步机制&lt;/h3&gt;

&lt;h4 id=&quot;硬件对并发的支持&quot;&gt;硬件对并发的支持&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在针对多处理器操作而设计的处理器中提供了一些特殊指令，用于管理对共享数据的并发访问。例如：&lt;strong&gt;比较并交换（Compare-and-Swap，CAS）&lt;/strong&gt;或者&lt;strong&gt;关联加载/条件存储（Load-Linked/Store-Conditional）&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CAS 的含义&lt;/strong&gt;是：“我认为 V 的值应该为 A，如果是，那么将V的值更新为 B，否则不修改并告诉 V 的值实际为多少”。&lt;/li&gt;
  &lt;li&gt;CAS 是一项乐观的技术，它希望能成功地执行更新操作，并且&lt;strong&gt;如果有另一个线程在最近一次检查后更新了该变量，那么 CAS 能检测到这个错误。并且，失败的线程不会挂起，而是被告知失败并可以重试&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CAS 的典型使用模式&lt;/strong&gt;是：首先从 V 中读取值 A，并根据 A 计算新值 B，然后再通过 CAS 以 C 子方式将 V 中的值由 A 变成 B（只要在这期间没有任何线程将v的值修改为其他值）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CAS VS 锁&lt;/strong&gt;：当竞争程度不高时，基于 CAS 的同步器在性能上远远超过了基于锁的同步器，而在没有竞争时甚至更高。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;原子变量类&quot;&gt;原子变量类&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;原子变量&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;原子变量比锁的粒度更细，量级更轻，它将发生竞争的范围缩小到单个变量上。&lt;/li&gt;
      &lt;li&gt;更新原子变量的快速（非竞争）路径不会比获取锁的快速路径慢，并且通常会更快，而它的慢速路径肯定比锁的慢速路径快，因为它不需要挂起或重新调度线程。&lt;/li&gt;
      &lt;li&gt;能够支持原子的和有条件的读 - 改 - 写操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;原子变量 VS 锁&lt;/strong&gt;：在高度竞争的情况下，锁的性能将超过原子变量的性能，但&lt;strong&gt;在更真实的竞争情况下，原子变量的性能将超过锁的性能&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;非阻塞算法&quot;&gt;非阻塞算法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;非阻塞算法&lt;/strong&gt;：如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;无锁（Lock-Free）算法&lt;/strong&gt;：如果在算法的每个步骤中都存在某个线程能够执行下去，那么这种算法也被称为无锁算法。&lt;/li&gt;
  &lt;li&gt;非阻塞算法虽然实现复杂，但是能提升性能，而且通常不会出现死锁和优先级反转这些问题。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;创建非阻塞算法的关键&lt;/strong&gt;在于，找出如何将原子修改的范围缩小到单个变量上，同时还要维护数据的一致性。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jcip.net/listings/ConcurrentStack.java&quot;&gt;使用 Treiber 算法构造非阻塞栈。&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jcip.net/listings/LinkedQueue.java&quot;&gt;使用 Michael-Scott 算法构造非阻塞链表。&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ABA问题&lt;/strong&gt;：在使用 CAS 时，如何确定“自从上次看到V的值为A以来，这个值是否发生了变化？”（如果在算法中采用自己的方式来管理节点对象的内存，那么就可能出现ABA问题）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java-内存模型&quot;&gt;Java 内存模型&lt;/h3&gt;

&lt;h4 id=&quot;内存模型&quot;&gt;内存模型&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;各种各样的因素导致&lt;strong&gt;线程无法看到变量的最新值&lt;/strong&gt;，所以从开发者的角度，如果没有进行同步处理，那么线程的内存操作看上去是以乱序执行。
    &lt;ul&gt;
      &lt;li&gt;在单线程中，JVM 能保证在线程中维护一种&lt;strong&gt;类似串行的语义&lt;/strong&gt;：即会保证线程的执行结果与以严格串行模式执行的结果一致。&lt;/li&gt;
      &lt;li&gt;然而在多线程中，由于 JVM 维护这种串行语义将导致很大的开销，所以需要由开发者提供额外的同步操作来保证正确性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JMM&lt;/strong&gt;：JMM 规定了 JVM 必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对于其他线程可见。&lt;/li&gt;
  &lt;li&gt;在不同的处理器架构中提供了不同级别的&lt;strong&gt;缓存一致性（Cache Coherence）&lt;/strong&gt;，其中一部分只提供最小的保证，即允许不同的处理器在任意时刻从同一个存储位置上看到不同的值。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;串行一致性&lt;/strong&gt;：程序执行一种简单假设：想象在程序中只存在唯一的操作执行顺序，而不考虑这些操作在何种处理器上执行，并且在每次读取变量时，都能获得在执行序列中（任何处理器）最近一次写入该变量的值。这种乐观的模型就被称为串行一致性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;重排序&lt;/strong&gt;：各种使操作延迟或者看似乱序执行的不同原因，都可以归为重排序。&lt;/li&gt;
  &lt;li&gt;同步将限制编译器、运行时和硬件对内存操作重排序的方式，从而在实施重排序时不会破坏 JMM 提供的可见性保证。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Happens-Before&lt;/strong&gt;：JMM 为程序中所有的操作定义了一个偏序关系，称之为 Happens-Before 。要想保证执行操作 B 的线程看到操作A的结果（无论A和B是否在同一个线程中执行），那么在A和B之间必须满足 Happens-Before 关系。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;借助（Piggyback）同步&lt;/strong&gt; ：将 Happens-Before 的程序顺序规则与其他某个顺序规则结合起来，从而对某个未被锁保护的变量的访问操作进行排序。&lt;/li&gt;
  &lt;li&gt;借助同步容易出错，需要谨慎使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;初始化的安全性&quot;&gt;初始化的安全性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;提前初始化（Eager Initialization）&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//完整代码：http://jcip.net/listings/EagerInitialization.java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EagerInitialization&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Resource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Resource&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getResource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要使用&lt;strong&gt;双重检查加锁（DCL）&lt;/strong&gt;，因为线程可能看到一个失效的状态值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;初始化安全性&lt;/strong&gt;将确保，对于对正确构造的对象，所有线程都能看到由构造函数为对象给各个 final 域设置的正确值，而不管采用何种方式来发布对象。而且，由某个 final 域到达的任意变量将同样对于其他线程是可见的。&lt;strong&gt;对于通过非 final 域可达的值，或者在构造过程完成之后可能改变的值，必须采用同步来确保可见性。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 13 Feb 2018 07:30:00 +0800</pubDate>
        <link>https://damondu.github.io//2018/02/13/java-concurrency-learning-4/</link>
        <guid isPermaLink="true">https://damondu.github.io//2018/02/13/java-concurrency-learning-4/</guid>
        
        <category>Java</category>
        
        <category>Concurrency</category>
        
        
      </item>
    
      <item>
        <title> Java 并发学习笔记(三)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这是我阅读&lt;a href=&quot;https://book.douban.com/subject/10484692/&quot;&gt;《 Java 并发编程实战》&lt;/a&gt;整理出的知识大纲，第三部分主要是关于活跃性问题的介绍和避免，性能的分析与优化以及如何对并发程序进行正确的测试。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;before-reading&quot;&gt;Before Reading&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;本篇文章对应原书 10~12 章的内容。&lt;/li&gt;
  &lt;li&gt;建议通读过原书的对应内容后再使用这份知识大纲。&lt;/li&gt;
  &lt;li&gt;大部分内容为原书的摘抄，少部分是我自己的归纳。&lt;/li&gt;
  &lt;li&gt;文章中的代码是从原书 example 中摘抄得来，你可以从&lt;a href=&quot;http://jcip.net/listings.html&quot;&gt;原书官网&lt;/a&gt;获取完整的代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;避免活跃性危险&quot;&gt;避免活跃性危险&lt;/h3&gt;

&lt;h4 id=&quot;死锁&quot;&gt;死锁&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;锁顺序死锁&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;发生原因：两个线程试图&lt;strong&gt;以不同的顺序来获得相同的锁&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;检查：对加锁行为进行全局分析&lt;/li&gt;
      &lt;li&gt;解决：如果所有线程以固定的顺序来获得锁，那么就不会发生锁顺序死锁；如果一个程序每次至多只能获得一个锁，那么就不会产生锁顺序死锁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;动态的锁顺序死锁&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;有时候，并不能清楚地知道是否在锁顺序上有足够的控制权来避免死锁的发生。锁的顺序可能取决于参数顺序，而参数顺序又取决于外部输入。&lt;/li&gt;
      &lt;li&gt;解决：在指定锁顺序时，可以&lt;strong&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;System.identityHasdCode&lt;/code&gt; 方法&lt;/strong&gt;。在极少数情况下，两个对象可能拥有相同的散列值。为了避免这种情况，可以使用&lt;strong&gt;“加时赛（Tie-Breaking）”锁&lt;/strong&gt;。在获得两个 Account 锁之前，首先获得这个“加时赛”锁，从而保证每次只有一个线程以未知的顺序获得这两个锁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;协作对象之间发生的死锁&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能会获取锁，或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;如果在持有锁的情况下调用某个外部方法，那么就需要警惕死锁&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;开放调用（Open Call）&lt;/strong&gt;：如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。
    &lt;ul&gt;
      &lt;li&gt;通过开放调用可以避免死锁。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;应该尽可能地使用开放调用&lt;/strong&gt;：分析一个完全依赖于开放调用的程序的活跃性，要比分析那些不依赖开放调用的程序的活跃性简单。&lt;/li&gt;
      &lt;li&gt;重新编写同步代码块可能会使得某个原子操作变为非原子操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;资源死锁&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;当多个线程在相同的资源集合上等待时，也会发生死锁。&lt;/li&gt;
      &lt;li&gt;原因：在请求两个或多个资源时不始终遵循相同的顺序；任务之间存在依赖，发生线程饥饿死锁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;死锁的避免和诊断&quot;&gt;死锁的避免和诊断&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;限时锁&lt;/strong&gt;：使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt; 类中的定时 &lt;code class=&quot;highlighter-rouge&quot;&gt;tryLock&lt;/code&gt; 功能来代替内置锁机制。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;线程转储（Thread Dump）&lt;/strong&gt;：JVM 通过线程转储来帮助识别死锁的发生。线程转储包括各个运行中的线程的栈追踪信息以及加锁信息。JVM将在等待关系图中通过搜索循环来找出死锁。如果发现了一个死锁，则获取相应的死锁信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;其他活跃性问题&quot;&gt;其他活跃性问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;饥饿（Starvation）&lt;/strong&gt;：当线程由于无法访问它所需要的资源而不能继续执行时，就发生了饥饿。
    &lt;ul&gt;
      &lt;li&gt;在大多数 Java 应用程序中，所有线程都具有相同的优先级，通过修改线程优先级所带来的&lt;strong&gt;效果通常不明显&lt;/strong&gt;。而且只要改变了线程的优先级，程序的行为就将与平台相关。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;活锁（Livelock）&lt;/strong&gt;：当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行时，就发生了活锁。
    &lt;ul&gt;
      &lt;li&gt;解决：在重试机制中引入随机性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;性能与可伸缩性&quot;&gt;性能与可伸缩性&lt;/h3&gt;

&lt;h4 id=&quot;性能指标与性能影响因素&quot;&gt;性能指标与性能影响因素&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当操作性能由于某种特定的资源而受到限制时，我们通常将该操作称为资源密集型的操作，例如，CPU密集型、数据库密集型等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;要想通过并发来获得更好的性能，需要做好两件事情&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;更有效地利用现有处理资源。&lt;/li&gt;
      &lt;li&gt;在出现新的处理资源时使程序尽可能地利用这些新资源。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;性能可以采用多个指标来衡量，其中一些指标（服务时间、等待时间）用于衡量程序的&lt;strong&gt;“运行速度”&lt;/strong&gt;，另一些指标（生产量、吞吐量）用于程序的&lt;strong&gt;“处理能力”&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;可伸缩性&lt;/strong&gt;：当增加计算资源时，程序的吞吐量或者处理能力应当相应地增加。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在进行可伸缩性调优时，其目的是设法将问题的计算并行化，从而能利用更多的计算资源来完成更多的工作。&lt;/li&gt;
      &lt;li&gt;对于服务器应用程序来说，“多少”这个方面一一可伸缩性、吞吐量和生产量，往往比“多快”这个方面更受重视。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先使程序正确运行，然后再提高运行速度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在使某个方案比其他方案“更快”之前，首先问自己一些问题：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;“更快”的含义是什么？&lt;/li&gt;
      &lt;li&gt;该方法在什么条件下运行得更快？在低负载还是高负载的情况下？大数据集还是小数据集？能否通过测试结果来验证你的答案？&lt;/li&gt;
      &lt;li&gt;这些条件在运行环境中的发生频率？能否通过测试结果来验证你的答案？&lt;/li&gt;
      &lt;li&gt;在其他不同条件的环境中能否使用这里的代码？&lt;/li&gt;
      &lt;li&gt;在实现这种性能提升时需要付出哪些隐含的代价，例如增加开发风险或维护开销？这种权衡是否合适？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Amdahl 定律&lt;/strong&gt;：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。假定 F 是必须被串行执行的部分，那么根据 Amdahl 定律，在包含 Ⅳ 个处理器的机器中，最高的加速比为：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/Amdahl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在所有的并发程序中都包含一些串行部分。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;线程开销与相应的优化&quot;&gt;线程开销与相应的优化&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;引入线程的开销&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;上下文切换：切换上下文的开销；在线程调度过程中需要访问由操作系统和 JVM 共享的数据结构；上下文切换会导致一些缓存缺失。&lt;/li&gt;
      &lt;li&gt;内存同步：会抑制一些编译器的优化操作；竞争的同步会导致竞争失败线程的阻塞。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不用过于担心非竞争同步带来的开销&lt;/strong&gt;，它对应用程序的整体性能的影响十分微小。&lt;/li&gt;
  &lt;li&gt;减少锁的竞争可以提高性能和可伸缩性。在并发程序中，限制可伸缩性的最主要瓶颈就是&lt;strong&gt;独占方式的资源锁&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;降低锁竞争程度的3个方向&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;减少锁的持有时间。&lt;/li&gt;
      &lt;li&gt;降低锁的请求频率。&lt;/li&gt;
      &lt;li&gt;使用带有协调机制的独占锁，允许更高的并发性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;减少锁竞争（提高可伸缩性）的具体方法&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;缩小锁的范围&lt;/strong&gt;：将一些锁无关的代码移出同步代码块（尤其是开销大的操作）。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;锁分解&lt;/strong&gt;：如果一个锁需要保护多个&lt;strong&gt;相互独立&lt;/strong&gt;的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁被请求的频率。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;锁分段&lt;/strong&gt;：将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，这种情
况被称为锁分段。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;避免热点域（Hot Field）&lt;/strong&gt;：一些常见的优化措施，例如将一些反复计算的结果缓存起来，都会引入一些“热点域”，而这些热点域往往会限制可伸缩性。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;使用其他方法替代独占锁&lt;/strong&gt;：使用一种&lt;strong&gt;友好并发的方式&lt;/strong&gt;来管理共享状态。例如：并发容器、读 - 写锁、不可变对象以及原子变量。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果在锁上存在&lt;strong&gt;适中而不是激烈的竞争&lt;/strong&gt;时，通过将一个锁分解为两个锁，能最大限度地提升性能（因为实际上是把这些锁转变为非竞争的锁）；把一个&lt;strong&gt;竞争激烈的&lt;/strong&gt;锁分解为两个锁时，这两个锁仍然可能都存在激烈的竞争，无法给可伸缩性带来极大的提高。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;锁分段的一个劣势在于&lt;/strong&gt;：要获取多个锁来实现独占访问将更加困难并且开销更高。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;监测 CPU 的利用率&lt;/strong&gt;：如果应用程序正在使 CPU 保持忙碌状态，那么可以使用监视工具来判断是否能通过增加额外的 CPU 来提升程序的性能。&lt;strong&gt;如果 CPU 的利用率很高，并且总会有可运行的线程在等待 CPU&lt;/strong&gt;，那么当增加更多的处理器时，程序的性能可能会得到提升。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不使用对象池&lt;/strong&gt;：通常，对象分配操作的开销比保证对象池同步的开销更低。（除非对象的创建和销毁操作开销十分巨大，但这个时候一般是对象设计存在不合理）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;减少上下文切换的开销&lt;/strong&gt;：一般是通过将异构任务分解。典型的例子是：在日志服务中，将 I/O 操作从日志处理请求的线程中分离出来。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;并发程序的测试&quot;&gt;并发程序的测试&lt;/h3&gt;

&lt;h4 id=&quot;正确性测试&quot;&gt;正确性测试&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在为某个并发类设计单元测试时，首先要找出程序的&lt;strong&gt;不变性条件和后验条件&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;对阻塞操作的测试&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在测试并发的基本属性时，&lt;strong&gt;需要引入多个线程&lt;/strong&gt;。大多数测试框架并不能很好地支持并发性测试，所以&lt;strong&gt;需要通过一些工作将成功或失败信息传递回主测试线程&lt;/strong&gt;，从而才能将相应的信息报告出来。&lt;/li&gt;
      &lt;li&gt;约定：每个测试必须等待它所创建的全部线程结束以后才能完成。&lt;/li&gt;
      &lt;li&gt;简单的实现方式是：使用中断，在一个单独的线程中启动一个阻塞操作，等到线程阻塞后再中断它，然后宣告阻塞操作成功。&lt;/li&gt;
      &lt;li&gt;“等待并直到线程阻塞后”要求我们：估计执行这些指令可能需要多长的时间，并且等待的时间会更长。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;测试阻塞行为以及对中断的响应&lt;/strong&gt;：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 完整代码：http://jcip.net/listings/TestBoundedBuffer.java&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testTakeBlocksWhenEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SemaphoreBoundedBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SemaphoreBoundedBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unused&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// if we get here, it's an error&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;taker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOCKUP_DETECT_TIMEOUT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;taker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
              
            &lt;span class=&quot;n&quot;&gt;taker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOCKUP_DETECT_TIMEOUT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;assertFalse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAlive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unexpected&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.getState&lt;/code&gt; 来验证线程能否在一个条件等待上阻塞，但这种方法
并&lt;strong&gt;不可靠&lt;/strong&gt;（线程可能通过自旋来实现阻塞）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;安全性测试&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;要想测试一个并发类在不可预测的并发访问情况下能否正确执行，需要创建多个线程来分别执行并发操作，并在执行一段时间后判断在测试中是否会出现问题。理论上，&lt;strong&gt;测试线程之间产生更多的并发交替操作，则更有可能找出错误&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;要开发一个良好的并发测试程序，或许比开发这些程序要测试的类更加困难。所以关键是：&lt;strong&gt;找到容易测试以及容易发生错误的属性，并且在测试中尽量不需要任何同步机制&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;提高测试效率&lt;/strong&gt;：使用两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;CountDownLatch&lt;/code&gt; （一个开始阀门，一个结束阀门），或者使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CyclicBarrier&lt;/code&gt; ，可以让测试线程尽可能的并发交替操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;资源管理的测试&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;检查程序有无发生资源泄露。&lt;/li&gt;
      &lt;li&gt;使用测量程序中内存使用情况的堆检查工具。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用回调函数&lt;/strong&gt;：通过在对象生命周期的一些已知位置上执行回调函数，可以判断在这些特定位置上的不变性条件有无得到保证。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.yield&lt;/code&gt;&lt;/strong&gt; ，可以产生更多的并发交替操作，提高发现并发错误的概率。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;性能测试&quot;&gt;性能测试&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;性能测试的目的&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;衡量应用程序中的端到端性能。&lt;/li&gt;
      &lt;li&gt;根据经验值来调整各种不同的限值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;得到每个操作的运行时间&lt;/strong&gt;：使用一个栅栏动作来测量启动和结束时间，相减整个运行过程的时间，然后除以总操作的数量，从而得到每次操作的运行时间。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;响应性衡量&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;两个方面：响应时间，响应时间的变动性。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;如果能获得更小的服务时间变动性，那么更长的平均服务时间是有意义的&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;除非线程由于密集的同步需求而被持续地阻塞，否则&lt;strong&gt;非公平&lt;/strong&gt;的信号量通常能实现&lt;strong&gt;更好的吞吐量&lt;/strong&gt;，而&lt;strong&gt;公平&lt;/strong&gt;的信号量则实现&lt;strong&gt;更低的变动性&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;避开性能测试的陷阱&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;：不可预测的垃圾回收会影响每次测试迭代的时间，从而让测试结果变得不可信。有两种解决方法：禁止测试时的垃圾回收；在测试时足够频繁地执行垃圾回收。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;动态编译&lt;/strong&gt;：动态编译的执行时间无法预测，会影响测试结果。三种解决方式：使测试程序运行足够长的时间；先运行被测试程序一段时间后再进行测试；在同一 JVM 上多次测试。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;对代码路径的不真实采样&lt;/strong&gt;：引入多线程的性能测试，即可避免编译器对代码路径的优化。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;不真实的竞争程度&lt;/strong&gt;：在并发测试中，应尽量模拟真实应用环境中的计算量和并发协调开销。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;无用代码的消除&lt;/strong&gt;：在正式产品和测试版本中，都应该选择“-server 模式”，从而提高消除无用代码的程度。同时，为了避免测试相关代码被当作无用代码消除，可以：&lt;strong&gt;计算某个派生对象中域的散列值，并将其与一个任意值比较，若相等则输出一个无用且可以忽略的消息&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;其他的 QA 方法&lt;/strong&gt;：&lt;strong&gt;质量保证（Quality Assurance，QA）&lt;/strong&gt;的目标应该是在给定的测试资源下实现最高的可信度。测试并非唯一的 QA 方法。
    &lt;ul&gt;
      &lt;li&gt;代码审查&lt;/li&gt;
      &lt;li&gt;静态分析工具&lt;/li&gt;
      &lt;li&gt;面向方面的测试技术&lt;/li&gt;
      &lt;li&gt;分析和监测工具&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 11 Feb 2018 02:00:00 +0800</pubDate>
        <link>https://damondu.github.io//2018/02/11/java-concurrency-learning-3/</link>
        <guid isPermaLink="true">https://damondu.github.io//2018/02/11/java-concurrency-learning-3/</guid>
        
        <category>Java</category>
        
        <category>Concurrency</category>
        
        
      </item>
    
      <item>
        <title> Java 并发学习笔记(二)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这是我阅读&lt;a href=&quot;https://book.douban.com/subject/10484692/&quot;&gt;《 Java 并发编程实战》&lt;/a&gt;整理出的知识大纲，第二部分主要是关于 Java 中如何使用 Executor 框架和线程池等技术来结构化地管理多线程应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;before-reading&quot;&gt;Before Reading&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;本篇文章对应原书 6~9 章的内容。&lt;/li&gt;
  &lt;li&gt;建议通读过原书的对应内容后再使用这份知识大纲。&lt;/li&gt;
  &lt;li&gt;大部分内容为原书的摘抄，少部分是我自己的归纳。&lt;/li&gt;
  &lt;li&gt;文章中的代码是从原书 example 中摘抄得来，你可以从&lt;a href=&quot;http://jcip.net/listings.html&quot;&gt;原书官网&lt;/a&gt;获取完整的代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;任务执行&quot;&gt;任务执行&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;服务器应用程序（典型的并发应用程序）设计的目标&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;正常&lt;/strong&gt;的负载下：应该能同时表现出&lt;strong&gt;良好的吞吐量和快速的响应性&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;当&lt;strong&gt;负荷过载&lt;/strong&gt;时：应用程序的&lt;strong&gt;性能应该是逐渐降低&lt;/strong&gt;，而不是直接失败。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;要实现并发应用程序的设计目标，应该
    &lt;ul&gt;
      &lt;li&gt;选择清晰的&lt;strong&gt;任务边界&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;选择明确的任务&lt;strong&gt;执行策略&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;任务边界&lt;/strong&gt;：大多数服务器应用程序都提供了一种自然的任务边界选择方式：&lt;strong&gt;以独立的客户请求为边界&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;执行策略&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;串行执行&lt;/strong&gt;：简单，性能糟糕（服务器资源利用率、吞吐量、响应性）&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;显式地为任务创建线程&lt;/strong&gt;：在正常负载下性能较好，但简单地为任务创建线程存在缺陷（尤其是线程数量大时）：线程生命周期的开销高、资源消耗高、稳定性差，导致在&lt;strong&gt;高负载时性能差&lt;/strong&gt;（也即是可用性低）。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;使用&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt; &lt;strong&gt;框架&lt;/strong&gt;：基于&lt;strong&gt;生产者 — 消费者模式&lt;/strong&gt;，提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; 来表示任务；提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html&quot;&gt;Executors&lt;/a&gt; ；&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html&quot;&gt;Executor&lt;/a&gt; ；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用-executor-框架&quot;&gt;使用 Executor 框架&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;线程池&lt;/strong&gt;：指管理一组同构工作线程的资源池。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;工作原理&lt;/strong&gt;：由工作者线程（Worker Thread）从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;使用线程池的好处&lt;/strong&gt;：
        &lt;ol&gt;
          &lt;li&gt;通过重用现有的线程而不是创建新线程，减少线程创建和销毁线程产生的巨大开销。&lt;/li&gt;
          &lt;li&gt;当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，提高了响应性。&lt;/li&gt;
          &lt;li&gt;基于线程池，应用程序的稳定性提高：在高负载时不会直接失败，而是平缓地降低性能。
            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool-int-java.util.concurrent.ThreadFactory-&quot;&gt;newFixedThreadPool&lt;/a&gt; / &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool--&quot;&gt;newCachedThreadPool&lt;/a&gt; / &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newSingleThreadExecutor--&quot;&gt;newSingleThreadExecutor&lt;/a&gt; / &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newScheduledThreadPool-int-&quot;&gt;newScheduledThreadPool&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;Interface ExecutorService&lt;/a&gt; 管理 &lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 的生命周期
    &lt;ul&gt;
      &lt;li&gt;三种生命状态：运行、关闭、已终止。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdown&lt;/code&gt; 方法执行平缓的关闭过程；&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdownNow&lt;/code&gt; 方法执行强制关闭过程。&lt;/li&gt;
      &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt; 关闭后提交的任务将由&lt;strong&gt;“拒绝执行处理器（Rejected Execution Handler）”&lt;/strong&gt;来处理。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;awaitTermination&lt;/code&gt; 等待 &lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt; 到达终止状态；&lt;code class=&quot;highlighter-rouge&quot;&gt;isTerminated&lt;/code&gt; 轮询 &lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt; 是否已经终止。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ScheduledThreadPoolExecutor&lt;/code&gt; 创建延迟任务和周期任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;进一步的分解任务以提高并行性&quot;&gt;进一步的分解任务以提高并行性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/bboyfeiyu/article/details/24851847&quot;&gt;&lt;strong&gt;区分 Runnable、Callable、Future、FutureTask&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Executor 中包含了一些辅助方法能将其他类型的任务封装为一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt; 表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; 方法的行为&lt;strong&gt;取决于任务的状态&lt;/strong&gt;（尚未开始、正在运行、已完成）。如果任务已经完成，那么   &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; 会立即返回或者抛出一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Exception&lt;/code&gt; ，如果任务没有完成，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; 将阻塞并直到任务完成。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 使用 Future 等待图片下载，实现异构任务（文字/图片）并行化
 * 完整代码：http://jcip.net/listings/FutureRenderer.java
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FutureRenderer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;renderPage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharSequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imageInfos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scanForImageInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//建立任务&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imageInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imageInfos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imageInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;downloadImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	    &lt;span class=&quot;c1&quot;&gt;//将任务封装为 Future&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;renderText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

      	&lt;span class=&quot;c1&quot;&gt;//尝试 Future.get()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imageData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ImageData&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imageData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;renderImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 重新设置线程的中断状态&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 因为不需要结果，所以取消任务&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExecutionException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;launderThrowable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Future.get()&lt;/code&gt; 拥有“状态依赖”的内在特性，因而&lt;strong&gt;调用者不需要知道任务的状态&lt;/strong&gt;，此外在任务提交和获得结果中包含的安全发布属性也确保了&lt;strong&gt;这个方法是线程安全的&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;strong&gt;完成服务（CompletionService）&lt;/strong&gt;来在计算完成后获取结果：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;工作原理&lt;/strong&gt;：整合了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt; 的功能，可以将 &lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt; 任务提交给它来执行，然后使用类似于队列操作的 &lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;poll&lt;/code&gt; 等方法来获得已完成的结果。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CompletionService&lt;/code&gt; 可以&lt;strong&gt;从两个方面&lt;/strong&gt;来&lt;strong&gt;提高页面渲染器的性能&lt;/strong&gt;：&lt;strong&gt;缩短总运行时间&lt;/strong&gt;：每个图片的下载从串行变为并行。&lt;strong&gt;提高响应性&lt;/strong&gt;：图片在下载完成后立刻显示出来，能使用户获得一个更加动态和更高响应性的用户界面。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Future.get()&lt;/code&gt; 方法设置时间限制可以实现&lt;strong&gt;为任务设定时限&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;取消与关闭&quot;&gt;取消与关闭&lt;/h3&gt;

&lt;h4 id=&quot;任务取消&quot;&gt;任务取消&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Java 没有提供任何机制来安全地终止线程，但它提供了&lt;strong&gt;中断（lnterruption）&lt;/strong&gt;，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;线程中断&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;每个线程都有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt; 类型的中断状态。当中断线程时，这个线程的中断状态将被设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt&lt;/code&gt; 方法能中断目标线程。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;islnterrupted&lt;/code&gt; 方法能返回目标线程的中断状态。&lt;/li&gt;
      &lt;li&gt;静态的 &lt;code class=&quot;highlighter-rouge&quot;&gt;interrupted&lt;/code&gt; 方法将清除当前线程的中断状态，并返回它之前的值，这也是&lt;strong&gt;清除中断状态的唯一方法。&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;中断操作&lt;strong&gt;并不会真正地中断&lt;/strong&gt;一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。（这些时刻也被称为取消点）&lt;/li&gt;
  &lt;li&gt;使用静态的 &lt;code class=&quot;highlighter-rouge&quot;&gt;interrupted&lt;/code&gt; 时会清除当前线程的中断状态，除非你想屏蔽这个中断，否则必须对它进行处理。&lt;/li&gt;
  &lt;li&gt;通常，中断是实现取消的最合理方式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;中断策略&lt;/strong&gt;：中断策略规定线程如何解释某个中断请求。当发现中断请求时，应该做哪些工作（如果需要的话），哪些工作单元对于中断来说是原子操作，以及以多快的速度来响应中断。&lt;/li&gt;
  &lt;li&gt;最合理的中断策略是某种形式的&lt;strong&gt;线程级（Thread-Level）取消操作&lt;/strong&gt;或&lt;strong&gt;服务级（Service-Level）取消操作&lt;/strong&gt;：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;停止一个基于线程的服务&quot;&gt;停止一个基于线程的服务&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;任务不会在其自己拥有的线程中执行，而是在某个服务（例如线程池）拥有的线程中执行。对于&lt;strong&gt;非线程所有者&lt;/strong&gt;的代码来说，&lt;strong&gt;应该小心地保存中断状态&lt;/strong&gt;，这样拥有线程的代码才能对中断做出响应。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;规则：若一个线程的中断策略是未知的，那么不可以中断该线程&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;两种策略处理 &lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt; ：传递异常和恢复中断状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于&lt;strong&gt;不支持取消但仍可以调用可中断阻塞方法的操作&lt;/strong&gt;：它们必须&lt;strong&gt;在循环中调用&lt;/strong&gt;这些方法，并在发现中断后重新尝试。它们应该在本地保存中断状态，并在&lt;strong&gt;返回前&lt;/strong&gt;（即 &lt;code class=&quot;highlighter-rouge&quot;&gt;finally&lt;/code&gt; 中）恢复状态而不是在&lt;strong&gt;捕获 &lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt; 时&lt;/strong&gt;恢复状态。如果过早地设置中断状态，就可能引起无限循环。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;在外部线程中断&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 完整代码：http://jcip.net/listings/TimedRun1.java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimedRun1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ScheduledExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelExec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newScheduledThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;timedRun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taskThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 创建一个 Runnable 来中断 taskThread&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cancelExec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;taskThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;缺点：违反规则——若一个线程的中断策略是未知的，那么不可以中断该线程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;在专门的线程中中断&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 完整代码：http://jcip.net/listings/TimedRun2.java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimedRun2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ScheduledExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelExec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newScheduledThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;timedRun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      	&lt;span class=&quot;c1&quot;&gt;// 为 Runnable 拓展中断策略&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RethrowableTask&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		   &lt;span class=&quot;c1&quot;&gt;// 实现了中断策略：若出现异常则再次抛出该异常&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rethrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;launderThrowable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// 创建已知中断策略的线程&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;RethrowableTask&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RethrowableTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taskThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;taskThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cancelExec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;taskThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// join 等待并检查任务中是否抛出异常&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;taskThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;rethrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#join(long)&quot;&gt;thread.join&lt;/a&gt; 的不足是：无法知道执行控制是因为线程正常退出而返回还是因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt; 超时而返回。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt; 处理中断实现取消&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimedRun&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taskExec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;timedRun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taskExec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeoutException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// task will be cancelled below&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExecutionException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// exception thrown in task; rethrow&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;launderThrowable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Harmless if task already completed&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// interrupt if running&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;在日志服务中添加可靠的取消操作&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;日志服务本身是个生产者 — 消费者问题，所以取消日志服务时要考虑生产者线程和消费者线程的同步取消。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 完整代码：http://jcip.net/listings/LogService.java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LogService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LoggerThread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loggerThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintWriter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GuardedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;this&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isShutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GuardedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;this&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reservations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;loggerThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;isShutdown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;loggerThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 生产者&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
       	&lt;span class=&quot;c1&quot;&gt;// 内置锁同步&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isShutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalStateException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reservations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 消费者&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoggerThread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      	&lt;span class=&quot;c1&quot;&gt;// 内置锁同步&lt;/span&gt;
                        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LogService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        	&lt;span class=&quot;c1&quot;&gt;// 被通知中断且没有需要处理的消息&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isShutdown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reservations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LogService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reservations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* retry */&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;毒丸（Poison Pill）对象&lt;/strong&gt;：另一种关闭生产者 一 消费者服务的方式就是使用毒丸对象。毒丸是指一个放在队列上的对象，其含义是：&lt;strong&gt;当得到这个对象时，立即停止&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;毒丸对象将确保消费者在关闭之前首先完成队列中的所有工作；而生产者在提交了“毒丸”对象后，将不会再提交任何工作。&lt;/li&gt;
      &lt;li&gt;只有在生产者和消费者的数量都已知的情况下，才可以使用毒丸对象。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实现跟踪&lt;strong&gt;被 &lt;code class=&quot;highlighter-rouge&quot;&gt;shutdownNow&lt;/code&gt; 取消的正在执行&lt;/strong&gt;的任务&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 完整代码：http://jcip.net/listings/TrackingExecutor.java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  	&lt;span class=&quot;c1&quot;&gt;// 这里存在以一个竞态条件，但对于幂等任务来说不会导致正确性问题&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isShutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isInterrupted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;tasksCancelledAtShutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发程序中一些异常（如 &lt;code class=&quot;highlighter-rouge&quot;&gt;RuntimeException&lt;/code&gt;）不会被捕捉到，要处理这些异常，一般通过结合“&lt;strong&gt;在工作者线程中主动捕捉异常”&lt;/strong&gt;和&lt;strong&gt;“使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;UncaughtExceptionHandler&lt;/code&gt; ”&lt;/strong&gt;这两种方法来实现。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;execute&lt;/code&gt; 提交的任务抛出的异常才会交给 &lt;code class=&quot;highlighter-rouge&quot;&gt;UncaughtExceptionHandler&lt;/code&gt; ，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;submit &lt;/code&gt;提交的任务则不会。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jvm-关闭&quot;&gt;JVM 关闭&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在&lt;strong&gt;正常关闭&lt;/strong&gt;中，JVM 首先调用所有已注册的&lt;strong&gt;关闭钩子（Shutdown Hook）&lt;/strong&gt;。当所有的关闭钩子都执行结束时，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;runFinalizersOnExit&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; ，那么 JVM 将运行&lt;strong&gt;终结器&lt;/strong&gt;，然后再停止。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;关闭钩子&lt;/strong&gt;：通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime.addShutdownHook&lt;/code&gt; 注册的但尚未开始的线程。
    &lt;ul&gt;
      &lt;li&gt;关闭钩子应该是线程安全的.&lt;/li&gt;
      &lt;li&gt;关闭钩子可以用于实现服务或应用程序的清理工作。&lt;/li&gt;
      &lt;li&gt;关闭钩子不应该依赖那些可能被应用程序或其他关闭钩子关闭的服务。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;守护线程（Daemon Thread）&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;当希望创建一个线程来执行一些辅助工作，但又不希望这个线程阻碍 JVM的关闭，这种情况下就需要使用守护线程。&lt;/li&gt;
      &lt;li&gt;当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。&lt;/li&gt;
      &lt;li&gt;普通线程与守护线程之间的&lt;strong&gt;差异仅在于当线程退出时发生的操作&lt;/strong&gt;：当 JVM 停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而 JVM 只是直接退出。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;应尽可能少地使用守护线程&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;终结器&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;对于其他一些资源，例如文件句柄或套接字句柄，当不再需要它们时，必须&lt;strong&gt;显式地&lt;/strong&gt;交还给操作系统。&lt;/li&gt;
      &lt;li&gt;在回收器释放它们后，调用它们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize&lt;/code&gt; 方法，从而保证一些持久化的资源被释放。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;避免使用终结器&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线程池的使用&quot;&gt;线程池的使用&lt;/h3&gt;

&lt;h4 id=&quot;任务和执行策略之间可能存在隐形耦合&quot;&gt;任务和执行策略之间可能存在隐形耦合&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在使用任务执行框架时，由于在&lt;strong&gt;任务和执行策略之间可能存在隐形耦合&lt;/strong&gt;，所以可能存在一些危险，主要考虑这几种任务：
    &lt;ul&gt;
      &lt;li&gt;依赖性任务。&lt;/li&gt;
      &lt;li&gt;使用线程封闭机制的任务。&lt;/li&gt;
      &lt;li&gt;对响应时间敏感的任务。&lt;/li&gt;
      &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 的任务。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果任务依赖于其他任务，那么可能产生&lt;strong&gt;线程饥饿死锁（Thread Starvation Deadlock）&lt;/strong&gt;，即任务需要无限期地等待一些必须由其他任务才能提供的资源或条件。
    &lt;ul&gt;
      &lt;li&gt;可以通过使用无界的线程池来解决。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;设置线程池的大小&quot;&gt;设置线程池的大小&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;通常不要固定线程池的大小，而应该通过某种配置机制来提供，或者根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime.availableProcessors&lt;/code&gt; 来动态计算。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;计算线程池的最优大小&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对于 CPU 资源的限制&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9C%80%E4%BC%98%E5%A4%A7%E5%B0%8F.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对于其他资源的限制：计算每个任务对该资源的需求量，然后用该资源的可用总量除以每个任务的需求量，所得结果就是线程池大小的上限。&lt;/li&gt;
      &lt;li&gt;线程池和资源池（如：数据连接池）的大小将会相互影响。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用-threadpoolexecutor&quot;&gt;使用 ThreadPoolExecutor&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt; 是一个灵活的、稳定的线程池，允许各种定制。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;corePoolSize&lt;/code&gt; ：&lt;strong&gt;基本大小&lt;/strong&gt;，也就是线程池的目标大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;maximumPoolSize&lt;/code&gt; ：&lt;strong&gt;最大大小&lt;/strong&gt;，可同时活动的线程数量的上限。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;队列任务&lt;/strong&gt;：如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个由 &lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 管理的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; 队列中等待，不会竞争CPU资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPooIExecutor&lt;/code&gt; 允许提供一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt; 来保存等待执行的任务，基本的任务排队方法有3种：&lt;strong&gt;无界队列、有界队列和同步移交（Synchronous Handoff）&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于有界队列，如果&lt;strong&gt;线程池较小而队列较大&lt;/strong&gt;，那么有助于减少内存使用量，降低 CPU 的使用率，同时还可以减少上下文切换，但付出的代价是可能会限制吞吐量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt; ，可以&lt;strong&gt;避免任务排队&lt;/strong&gt;，以及直接将任务从生产者移交给工作者线程。&lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt; &lt;strong&gt;不是一个真正的队列&lt;/strong&gt;，而是一种在线程之间进行移交的机制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;饱和策略&lt;/strong&gt;：当有界队列被填满后，饱和策略开始发挥作用。 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPooIExecutor&lt;/code&gt; 的饱和策略可以通过调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;setRejectedExecutionHandler&lt;/code&gt; 来修改。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AbortPolicy&lt;/code&gt;：中止，默认的饱和策略，抛出未检查的 &lt;code class=&quot;highlighter-rouge&quot;&gt;RejectedExecutionException&lt;/code&gt; 。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DiscardPolicy&lt;/code&gt;：抛弃，且不抛出异常。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DiscardOldestPolicy&lt;/code&gt;：抛弃最旧，且不抛出异常。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CallerRunsPolicy&lt;/code&gt;：调用者运行，不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用调用者运行策略的优点&lt;/strong&gt;：当服务器过载，这种过载情况会逐渐&lt;strong&gt;向外蔓延&lt;/strong&gt;开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下&lt;strong&gt;实现一种平缓的性能降低&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过指定一个线程工厂方法，可以定制线程池的配置信息。&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 完整代码：http://jcip.net/listings/MyThreadFactory.java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThreadFactory&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poolName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MyThreadFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poolName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;poolName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poolName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MyAppThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poolName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在调用完 &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPooIExecutor&lt;/code&gt; 的构造函数后，仍然可以通过&lt;strong&gt;设置函数（Setter）&lt;/strong&gt;来修改大多数传递给它的构造函数的参数。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;unconfigurableExecutorService&lt;/code&gt; 来包装可以防止通过 Setter 修改。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过改写 &lt;code class=&quot;highlighter-rouge&quot;&gt;beforeExecute&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;afterExecute&lt;/code&gt; 方法，可以添加日志、计时、监视或统计信息收集的功能；改写 &lt;code class=&quot;highlighter-rouge&quot;&gt;terminated&lt;/code&gt; 可以用来释放 &lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 在其生命周期里分配的各种资源，以及实现执行发送通知、记录日志或者收集finalize统计信息等操作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;迭代算法的并行化&quot;&gt;迭代算法的并行化&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;迭代并行化的条件&lt;/strong&gt;：在循环体中，每一次迭代是独立的；更进一步，只有当每个迭代操作执行的工作量大于管理一个新线程的开销，并行化才有意义。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;谜题框架&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;“谜题”&lt;strong&gt;定义&lt;/strong&gt;为：包含了一个初始位置，一个目标位置，以及用于判断是否是有效移动的规则集。&lt;/li&gt;
      &lt;li&gt;并发的谜题解答器：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 完整代码：http://jcip.net/listings/ConcurrentPuzzleSolver.java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcurrentPuzzleSolver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Puzzle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;puzzle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConcurrentMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ValueLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PuzzleNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ValueLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PuzzleNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;();&lt;/span&gt;
      
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;puzzle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;initialPosition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 阻塞直到找到解答&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;PuzzleNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solnPuzzleNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;solnPuzzleNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solnPuzzleNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asMoveList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PuzzleNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SolverTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SolverTask&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PuzzleNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 找到解答或者已完全遍历&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;puzzle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isGoal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;puzzle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;legalMoves&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;puzzle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;使用闭锁，可以检测是否有线程已经找到一个解答。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;用户图形界面应用程序&quot;&gt;用户图形界面应用程序&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;GUI 是单线程的原因&lt;/strong&gt;：多线程的 GUI 容易发生死锁问题。
    &lt;ol&gt;
      &lt;li&gt;多线程下，输入事件的处理过程（气泡上升）与GUI组件的面向对象模型（气泡下降）之间会存在错误的交互。&lt;/li&gt;
      &lt;li&gt;MVC 设计模式进一步增加了出现不一致锁定顺序的风险。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;单线程的 GUI 框架通过&lt;strong&gt;线程封闭机制&lt;/strong&gt;来实现线程安全性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;处理-gui-任务&quot;&gt;处理 GUI 任务&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;对于&lt;strong&gt;短时间且只访问 GUI 对象&lt;/strong&gt;的 GUI 任务，基本上所有操作都可以直接在事件线程中进行。&lt;/li&gt;
  &lt;li&gt;对于&lt;strong&gt;长时间以及复杂&lt;/strong&gt;的 GUI 任务，这些任务必须在另外的线程中运行以保存 GUI 的高响应性。同时，可能还有一些另外的实现需求，例如：
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;http://jcip.net/listings/ListenerExamples.java&quot;&gt;取消任务&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://jcip.net/listings/BackgroundTask.java&quot;&gt;进度标识、完成标识&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;共享数据模型&quot;&gt;共享数据模型&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;简单情况下，其他线程无法访问数据模型，GUI 应用程序只需简单地静态加载数据模型；但在一些情况下，数据在 GUI 程序进出时由多个线程共享。这种情况下，有两种解决数据同步性的方法：
    &lt;ol&gt;
      &lt;li&gt;实现线程安全的数据模型：但要构建一个既能提供高效的并发访问又能在旧数据无效后不再维护它们的数据结构却并不容易。&lt;/li&gt;
      &lt;li&gt;采用&lt;strong&gt;分解数据模型的设计模式&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;分解模型的设计模式中，&lt;strong&gt;表现模型&lt;/strong&gt;被封闭在事件线程中，而其他模型，即&lt;strong&gt;共享模型&lt;/strong&gt;，是线程安全的。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;表现模型可以在共享模型中得到更新&lt;/strong&gt;：通过将相关状态的快照嵌入到更新消息中，或者由表现模型在收到更新事件时直接从共享模型中获取数据。&lt;/li&gt;
      &lt;li&gt;通过快照实现更新，虽然简单，但是当数据模型很大或更新频率高时效率低下。采取&lt;strong&gt;增量更新&lt;/strong&gt;可以解决这个问题。并且，增量更新还能带来细粒度的变化信息，从而&lt;strong&gt;优化 GUI 的视觉效果&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当某个工具必须被实现为单线程子系统是，可以借鉴 GUI 的实现，采取线程封闭来实现。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 09 Feb 2018 03:00:00 +0800</pubDate>
        <link>https://damondu.github.io//2018/02/09/java-concurrency-learning-2/</link>
        <guid isPermaLink="true">https://damondu.github.io//2018/02/09/java-concurrency-learning-2/</guid>
        
        <category>Java</category>
        
        <category>Concurrency</category>
        
        
      </item>
    
      <item>
        <title> Java 并发学习笔记(一)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这是我阅读&lt;a href=&quot;https://book.douban.com/subject/10484692/&quot;&gt;《 Java 并发编程实战》&lt;/a&gt;整理出的知识大纲，第一部分主要是一些关于并发与多线程的基本概念和 Java 中并发编程的基础。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;before-reading&quot;&gt;Before Reading&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;本篇文章对应原书 １~5 章的内容。&lt;/li&gt;
  &lt;li&gt;建议通读过原书的对应内容后再使用这份知识大纲。&lt;/li&gt;
  &lt;li&gt;大部分内容为原书的摘抄，少部分是我自己的归纳。&lt;/li&gt;
  &lt;li&gt;文章中的代码是从原书 example 中摘抄得来，你可以从&lt;a href=&quot;http://jcip.net/listings.html&quot;&gt;原书官网&lt;/a&gt;获取完整的代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;多线程简介&quot;&gt;多线程简介&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;（以&lt;strong&gt;线程&lt;/strong&gt;为对象）研究并发的&lt;strong&gt;动机&lt;/strong&gt;：由于同一个进程中的所有线程都将共享进程的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现一种&lt;strong&gt;比在进程间共享数据粒度更细&lt;/strong&gt;的数据共享机制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;多线程的优势&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;发挥多处理器的优势：提高系统&lt;strong&gt;吞吐率&lt;/strong&gt;（其实也能提升单处理器系统的吞吐率，主要是减少了等待 I/O 的时间）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;简化建模：使用线程可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;简化异步事件的处理：单线程程序中对异步事件的处理：若使用阻塞 I/O 则会造成性能下降；若使用非阻塞 I/O 则复杂度高且易出错。在多线程中，则可简单地使用阻塞 I/O 处理。&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;“异步”（asynchronous）在中文语境里的使用较为混乱，在各种中文译本和技术文章里常常不够统一，常见的理解如下：一、指&lt;strong&gt;异步事件（Asynchronous Event）&lt;/strong&gt;，即事件结果无法在执行后立即获得，需要在一段较长的时间后才能获得；二、指&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_communication&quot;&gt;异步传输/异步通信（Asynchronous Communication）&lt;/a&gt;&lt;/strong&gt;，即数据的接收方和传输方不需要使用一个同步的时钟，在计算机领域可以理解为遇到异步事件时不阻塞而继续执行后续代码，典型的例子就是异步 I/O。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;响应更灵敏的用户界面（GUI）&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;多线程带来的问题&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;安全性问题：多个线程执行顺序的不可预测带来的运行结果确性上的不可预测。&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;认为一段代码是非线程安全的（not thread safe），并不是说其运行结果必然是错的，而是指其运行结果在多线程环境下无法保证绝对的正确性。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;活跃性问题：当某个操作无法继续执行下去，就会发生活跃性问题（例如死循环）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;性能问题：线程切换时的上下文切换操作（Context Switch）造成极大的性能开销。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;线程安全性需求的蔓延&lt;/strong&gt;：当某个框架在应用程序中引入并发性时，通常不可能将并发性仅局限于框架代码，因为框架本身会回调（Callback）应用程序的代码，而这些代码将访问应用程序的状态。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线程安全性&quot;&gt;&lt;strong&gt;线程安全性&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;编写线程安全的代码的&lt;strong&gt;核心在于要对状态访问操作进行管理&lt;/strong&gt;，更具体地，是对&lt;strong&gt;共享的（Shared）&lt;/strong&gt;和&lt;strong&gt;可变的（Mutable）&lt;/strong&gt;状态的访问管理。“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;处理安全性问题的三种方式&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;不在线程之间共享该状态变量&lt;/li&gt;
      &lt;li&gt;将状态变量设置为不可变&lt;/li&gt;
      &lt;li&gt;在访问状态变量时适用同步&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;线程安全性的定义：&lt;/strong&gt;当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在线程安全性的定义中，最核心的概念就是&lt;strong&gt;正确性&lt;/strong&gt;。 正确性的含义是，某个类的行为与其&lt;strong&gt;规范&lt;/strong&gt;完全一致。&lt;/li&gt;
      &lt;li&gt;在良好的&lt;strong&gt;规范&lt;/strong&gt;中通常会定义各种&lt;strong&gt;不变性条件（Invariant）&lt;/strong&gt;来约束对象的状态，以及定义各种&lt;strong&gt;后验条件（Postcondition）&lt;/strong&gt;来描述对象操作的结果。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;注意区分不可变（immutable）和不变性（Invariant）。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;无状态对象一定是线程安全的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;原子性&quot;&gt;原子性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;竞态问题（Race Condition）&lt;/strong&gt;：两个或多个进程对共享的数据进行读或写的操作时，&lt;strong&gt;最终的结果取决于这些进程的执行顺序&lt;/strong&gt;。可以简单地理解为：会引发线程安全性问题的情况。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;大多数竞态条件的&lt;strong&gt;本质&lt;/strong&gt;——基于一种可能失效的观察结果来做出判断或者执行某个计算。&lt;/li&gt;
      &lt;li&gt;典型例子：“先检查后执行”/“读取—修改—写入”。&lt;/li&gt;
      &lt;li&gt;竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;原子操作&lt;/strong&gt;：对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是以一个原子的方式执行的操作。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/atomic/package-summary.html&quot;&gt;Package java.util.concurrent.atomic&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;加锁机制&quot;&gt;加锁机制&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;同步代码块（Synchronized Block）&lt;/strong&gt;：线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//acomic operation &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;内置锁&lt;/strong&gt;：每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁&lt;strong&gt;（lntrinsic Lock）&lt;/strong&gt;或&lt;strong&gt;监视器锁（Monitor Lock）&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Java 的内置锁相当于一种&lt;strong&gt;互斥体（或互斥锁）&lt;/strong&gt;，最多只有一个线程能持有这种锁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;锁的&lt;strong&gt;可重入性&lt;/strong&gt;：可重入意味着线程可以进入任何一个它已经拥有的锁所同步着的代码块。“重入”意味着锁的操作粒度是“线程”而不是“调用”。&lt;strong&gt;Java 内置锁是可重入的。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个共享的和可变的变量都应该&lt;strong&gt;只由一个锁来保护&lt;/strong&gt;。当不变性条件涉及多个状态变量时，还需保证不变性条件中的每一个变量都有同一个锁保护。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;不良并发（Poor Concurrency）应用程序&lt;/strong&gt;：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;同步代码块的设置策略&lt;/strong&gt;：应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，但也不能将同步代码块分解得过细，因为获取和释放锁等操作是有一定性能开销的。&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 缓存最近执行因数分解的数值及其计算结果的 Servlet
 * 完整代码：http://jcip.net/listings/CachedFactorizer.java
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ThreadSafe&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CachedFactorizer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GenericServlet&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Servlet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GuardedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;this&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GuardedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;this&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GuardedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;this&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GuardedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;this&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cacheHits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getHits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCacheHitRatio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cacheHits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extractFromRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cacheHits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//不影响共享状态且执行时间较长的操作&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;lastNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;lastFactors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;encodeIntoResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;对象的共享&quot;&gt;对象的共享&lt;/h3&gt;

&lt;h4 id=&quot;可见性&quot;&gt;可见性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;可见性（VIsibility）&lt;/strong&gt;：当一个线程修改了对象状态后，其他线程可以看到发生的状态变化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在缺乏足够同步的多线程程序中，由于代码&lt;strong&gt;重排序（Reordering）&lt;/strong&gt;的存在，内存操作的执行顺序几乎是无法确定的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在缺乏同步的程序中可能产生错误结果的一种情况：&lt;strong&gt;失效数据&lt;/strong&gt;。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;最低安全性（out-of-thin-airsafety）&lt;/strong&gt;：当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-airsafety）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;加锁与可见性&lt;/strong&gt;：加锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt; &lt;strong&gt;变量&lt;/strong&gt;：一种稍弱的同步机制，确保将变量的更新操作通知到其他线程。（编译器和运行时都不会将该变量上的操作进行重排序）。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;仅当 &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 变量能简化代码的实现以及对同步策略的验证时才应该适用它，因为通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 来控制状态的可见性比使用加锁机制脆弱且难以理解。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;当且仅当满足以下所有条件时，才应该使用&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt; &lt;strong&gt;变量&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。&lt;/li&gt;
      &lt;li&gt;该变量不会与其他状态变量一起纳入不变性条件中。&lt;/li&gt;
      &lt;li&gt;在访问变量时不需要加锁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;发布与逸出&quot;&gt;发布与逸出&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;发布（Publish）&lt;/strong&gt;：使对象能够在当前作用域之外的代码中使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;逸出（Escape）&lt;/strong&gt;：发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。当某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;当发布某个对象时，可能会间接地发布其他对象。&lt;/strong&gt;当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;当把一个对象传递给某个外部方法时，就相当于发布了这个对象。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;外部（Alien）方法&lt;/strong&gt;：假定有一个类 C，外部（Alien）方法指行为并不完全由 C 来规定的方法，包括其他类中定义的方法以及类C中可以被改写的方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;不要在构造过程中使用 this 引用逸出。&lt;/strong&gt;例如：在构造函数中启动一个线程。可以通过延迟启动，或者使用一个私有构造函数与公共工厂方法来避免逸出。&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 使用工厂方法来防止 this 引用在构造过程中逸出
 * 完整代码：http://jcip.net/listings/SafeListener.java
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SafeListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SafeListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EventListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafeListener&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EventSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SafeListener&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafeListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registerListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;safe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;线程封闭（Thread Confinement）&lt;/strong&gt;：一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为&lt;strong&gt;线程封闭（Thread Confinement）&lt;/strong&gt;，它是实现线程安全性的最简单方式之一。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Ad-hoc 线程封闭&lt;/strong&gt;：维护线程封闭性的职责&lt;strong&gt;完全&lt;/strong&gt;由程序实现来承担。Ad-hoc线程封闭是&lt;strong&gt;非常脆弱&lt;/strong&gt;的。当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个&lt;strong&gt;单线程子系统&lt;/strong&gt;。在某些情况下，单线程子系统提供的简便性要胜过Ad-hoc线程封闭技术的脆弱性。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;栈封闭&lt;/strong&gt;：线程封闭的一种特例。在栈封闭中，&lt;strong&gt;只能通过局部变量&lt;/strong&gt;才能访问对象。栈封闭（也被称为线程内部使用或者线程局部使用）比Ad-hoc线程封闭更&lt;strong&gt;易于维护&lt;/strong&gt;，也&lt;strong&gt;更加健壮&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; &lt;strong&gt;类&lt;/strong&gt;：这个类能使线程中的某个值与保存值的对象关联起来。&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt; 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; 总是返回由当前执行线程在调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt; 时设置的最新值。&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt; 通常用于防止对&lt;strong&gt;可变的单实例变量（Singleton）或全局变量&lt;/strong&gt;进行共享。&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html&quot;&gt;Class ThreadLocal&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;不变性&quot;&gt;不变性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;不可变对象（Immutable Object）&lt;/strong&gt;：如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;不可变对象一定是线程安全的。&lt;/li&gt;
      &lt;li&gt;不可变性并不等于将对象中所有的域都声明为 &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; 类型，即使对象中所有的域都是 &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; 类型的，这个对象也仍然是可变的，因为在 &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; 类型的域中可以保存对可变对象的引用。&lt;/li&gt;
      &lt;li&gt;“不可变的对象”与“不可变的对象引用”之间存在着差异。保存在不可变对象中的程序状态仍然可以更新，即通过&lt;strong&gt;将一个保存新状态的实例来“替换”原有的不可变对象。&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;当满足以下条件时，对象才是不可变的&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对象创建以后其状态就不能修改。&lt;/li&gt;
      &lt;li&gt;对象的所有域都是 &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; 类型。&lt;/li&gt;
      &lt;li&gt;对象是正确创建的（在对象的创建期间，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 引用没有逸出）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;即使对象是可变的，通过将对象的某些域声明为 &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; 类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于&lt;strong&gt;限制了该对象可能的状态集合&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 类型发布不可变对象来保证线程安全&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Immutable holder for caching a number and its factors
 * 完整代码：http://jcip.net/listings/OneValueCache.java
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Immutable&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OneValueCache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OneValueCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                         &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lastNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lastFactors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;copyOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;copyOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Caching the last result using a volatile reference to an immutable holder object
 * 完整代码：http://jcip.net/listings/VolatileCachedFactorizer.java
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ThreadSafe&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VolatileCachedFactorizer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GenericServlet&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Servlet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OneValueCache&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OneValueCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServletResponse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extractFromRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFactors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OneValueCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;encodeIntoResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;即使在发布不可变对象的引用时没有使用同步，也仍然可以安全地访问该对象。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;安全发布&quot;&gt;安全发布&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;一个正确构造的对象可以通过以下方式来安全地发布&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在静态初始化函数中初始化一个对象引用。&lt;/li&gt;
      &lt;li&gt;将对象的引用保存到 &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 类型的域或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicReference&lt;/code&gt; 对象中。&lt;/li&gt;
      &lt;li&gt;将对象的引用保存到某个正确构造对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; 类型域中。&lt;/li&gt;
      &lt;li&gt;将对象的引用保存到一个由锁保护的域中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事实不可变对象（Effectively Immutable Object）&lt;/strong&gt;：如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为事实不可变对象（Effectively Immutable Object）。通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可变对象的安全发布&lt;/strong&gt;：如果对象在构造后可以修改，那么安全发布只能确保&lt;strong&gt;“发布当时”&lt;/strong&gt;状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在&lt;strong&gt;每次&lt;/strong&gt;对象访问时同样需要使用同步来确保后续修改操作的可见性。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;对象的发布需求取决于它的可变性&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;不可变对象可以通过任意机制来发布。&lt;/li&gt;
      &lt;li&gt;事实不可变对象必须通过安全方式来发布。&lt;/li&gt;
      &lt;li&gt;可变对象必须通过安全方式发布，且必须是线程安全的或者由某个锁保护起来。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;对象的组合&quot;&gt;对象的组合&lt;/h3&gt;

&lt;h4 id=&quot;实例封闭&quot;&gt;实例封闭&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;实例封闭（Instance Confinement）&lt;/strong&gt;：也称封闭，将数据封装在对象内部，将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时能持有正确的锁。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;实例封闭是构建线程安全类的一个最简单的方式，具有灵活性。&lt;/li&gt;
      &lt;li&gt;通过装饰器（Decorator）实现线程安全本质上就是一种实例封闭。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Using confinement to ensure thread safety
 * 完整代码：http://jcip.net/listings/VolatileCachedFactorizer.java
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ThreadSafe&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PersonSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@GuardedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;this&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mySet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addPerson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;containsPerson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Java 监视器模式&lt;/strong&gt;：把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用私有锁而不是置锁（或任何其他可通过公有方式访问的锁）有许多优点。&lt;/strong&gt;私有的锁对象可以将锁封装起来，使客户代码无法得到锁，但客户代码可以通过公有方法来访问锁，以便（正确或者不正确地）参与到它的同步策略中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;委托&quot;&gt;委托&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;线程安全性的委托&lt;/strong&gt;：向一个无状态的类 A 中添加一个线程安全的类型 B 的属性，所得组合对象仍然是线程安全的，因为A的状态就是线程安全类B的状态，并且A没有对B的状态增加额外的有效性的约束，则可以说A将它的线程安全性&lt;strong&gt;委托&lt;/strong&gt;给了B。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以将线程安全性委托给&lt;strong&gt;多个&lt;/strong&gt;底层的状态变量，只要满足：状态变量之间是&lt;strong&gt;相互独立且线程安全&lt;/strong&gt;的，并且不&lt;strong&gt;存在将状态变量转化为无效状态的操作&lt;/strong&gt;即可。（然而状态之间并非相互独立）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改接口以发布底层的可变状态&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 安全发布底层状态的车辆追踪器
 * 完整代码：http://jcip.net/listings/PublishingVehicleTracker.java
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ThreadSafe&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PublishingVehicleTracker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafePoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafePoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unmodifiableMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PublishingVehicleTracker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafePoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;locations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConcurrentHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafePoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unmodifiableMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unmodifiableMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafePoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getLocations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unmodifiableMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SafePoint&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getLocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setLocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;invalid vehicle name: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;在现有的线程安全类中添加功能的方法&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;修改&lt;/strong&gt;原有的类：安全且容易理解与维护，但往往无法做到。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;扩展&lt;/strong&gt;原有的类：并非所有的类都将所有状态向子类公开；脆弱，不易维护。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;客户端加锁&lt;/strong&gt;：对于使用某个对象 x 的客户端代码，使用 x 本身用于保护其状态的锁来保护这段客户代码；更加脆弱、高耦合、不易维护。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;组合（Composition）&lt;/strong&gt;：通过委托实现，虽然增加额外的同步层带来了轻微的性能损失但更为健壮。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 通过客户端加锁实现“若没有则增加”
 * 完整代码：http://jcip.net/listings/ListHelpers.java
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ThreadSafe&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GoodListHelper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;synchronizedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;());&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;absent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;absent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;absent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 通过组合加锁实现“若没有则增加”
 * 完整代码：http://jcip.net/listings/ImprovedList.java
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ThreadSafe&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ImprovedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ImprovedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基础构建模块&quot;&gt;基础构建模块&lt;/h3&gt;

&lt;h4 id=&quot;同步容器&quot;&gt;同步容器&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;同步容器&lt;/strong&gt;包括 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html&quot;&gt;Vector&lt;/a&gt; 和 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt; 。JDK1.2 提供了Collections.synchronizedXxx等工程方法，该方法将指定集合对象的状态封装起来，并对每个公有方法都进行
同步，并返回指定集合对象对应的同步对象。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;同步容器类的问题&lt;/strong&gt;：虽然在单个方法被使用时可以保证线程安全，但&lt;strong&gt;复合操作&lt;/strong&gt;则需要额外的客户端加锁来保护。&lt;/li&gt;
      &lt;li&gt;由于“及时失败”（fail-first）机制，当迭代器发现容器在迭代过程中被修改时，就会抛出一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt; 异常。&lt;/li&gt;
      &lt;li&gt;解决 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt; 异常的方法：一种方法是对迭代行为加锁，但是降低了并发性且可能会产生死锁；另一种方法是“克隆”整个容器并让迭代在克隆容器上进行，缺点是克隆容器时的有性能开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;并发容器&quot;&gt;并发容器&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;并发容器&lt;/strong&gt;： &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; / &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html&quot;&gt;CopyOnWriteArrayList&lt;/a&gt; / &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html&quot;&gt;Queue&lt;/a&gt; / &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html&quot;&gt;BlockingQueue&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;并发容器的迭代器不会抛出 &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt; 异常且具有弱一致性（Weakly Consistent）。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但是不保证）在迭代器被构造后将修改操作反映给容器。&lt;/li&gt;
      &lt;li&gt;并发容器的一些方法（如 &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;isEmpty&lt;/code&gt;）的语义被略微减弱以反映并发特性。例如：允许 &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; 返回一个近似值而非精确值。&lt;/li&gt;
      &lt;li&gt;一些常见的复合操作在容器中实现为原子操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;阻塞队列支持&lt;strong&gt;生产者—消费者模式&lt;/strong&gt;，这种模式消除了生产者与消费者之间的代码依赖性，简化工作负载的管理。常见的生产者—消费者模式：线程池和工作队列的组合。&lt;/li&gt;
  &lt;li&gt;双端队列（Deque）适用于工&lt;strong&gt;作密取模式（Work Stealing）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;同步工具类&quot;&gt;同步工具类&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;同步工具类&lt;/strong&gt;根据自身的状态来协调线程的控制类。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;闭锁（Latch）&lt;/strong&gt;：延迟线程的进度直到其到达终止状态，用来确保某些活动知道其他活动都完成后才继续执行。
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html&quot;&gt;CountDownLatch&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;打开闭锁使得主线程能同时释放所有工作线程，而光笔闭锁则使得主线程能够等待最后一个线程执行完成。&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/FutureTask.html&quot;&gt;FutureTask&lt;/a&gt; 也可用于实现闭锁，它可以处于三种状态：等待运行、正在运行、运行完成。它可以用于使计算在使用计算结果之前启动，减少等待计算的时间。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;计数信号量（Couting Semaphore）&lt;/strong&gt;：用来控制同时访问某个特定资源的操作量，或者同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;栅栏（Barrier）&lt;/strong&gt;：类似于闭锁，它能阻塞一组线程直到某个事件发生。与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。（即闭锁用于等待事件，而栅栏用于等待其他线程）
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html&quot;&gt;CyclicBarrier&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;两方栅栏 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html&quot;&gt;Exchanger&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 06 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://damondu.github.io//2018/02/06/java-concurrency-learning-1/</link>
        <guid isPermaLink="true">https://damondu.github.io//2018/02/06/java-concurrency-learning-1/</guid>
        
        <category>Java</category>
        
        <category>Concurrency</category>
        
        
      </item>
    
      <item>
        <title>深入理解Java虚拟机(三)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这是我在阅读周志明版的《深入理解 Java 虚拟机》并进行知识复盘的时候整理出的知识大纲式的文档，第三部分主要关于程序编译与代码优化。至于书中最后一部分内容——Java 并发的内容我不打算精读，主要是并发十分复杂和重要，不是两个章节可以说清楚的，所以我打算在另外的专门讲 Java 并发的书籍中学习这部分内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;before-reading&quot;&gt;Before Reading&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;本篇文章对应原书 10~11 章的内容。&lt;/li&gt;
  &lt;li&gt;建议通读过原书的对应内容后再使用这份知识大纲。&lt;/li&gt;
  &lt;li&gt;大部分内容为原书的摘抄，少部分是我自己的归纳。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;一-早期编译期优化&quot;&gt;(一) 早期（编译期）优化&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Java 中 3 类编译过程：&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;前端编译器：把 *.java 文件转变成 *.class 文件；例如 javac&lt;/li&gt;
      &lt;li&gt;后端编译器/JIT 编译器（Just In Time Compiler）：把字节码转变成机器码；例如 HotSpot 的 C1/C2&lt;/li&gt;
      &lt;li&gt;AOT 编译器（Ahead Of Time Compiler）：直接把 *.java 文件编译成机器码；例如 Excelsior JET&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;javac 编译过程：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;javac编译过程&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;解析与填充符号表过程：&lt;/strong&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;过程&lt;/th&gt;
          &lt;th&gt;实现类&lt;/th&gt;
          &lt;th&gt;出口&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;词法分析&lt;/td&gt;
          &lt;td&gt;com.sun.tools.javac.Scanner&lt;/td&gt;
          &lt;td&gt;标记（Token）集合&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;语法分析&lt;/td&gt;
          &lt;td&gt;com.sun.tools.javac.Parser&lt;/td&gt;
          &lt;td&gt;抽象语法树（Abstract Syntax Tree，AST）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;填充符号表&lt;/td&gt;
          &lt;td&gt;com.sun.tools.javac.comp.Enter&lt;/td&gt;
          &lt;td&gt;待处理列表（To Do List）&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;符号表（Symbol Table）&lt;/strong&gt;是有一组符号地址和符号信息构成的表格&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;待处理列表&lt;/strong&gt;包含了每一个编译单元的抽象语法树的顶级节点，以及 package-info.java 的顶级节点（若存在）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;注释处理器&lt;/strong&gt;可以读取、修改、添加抽象语法树中的任意元素。若处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有修改为止。每一次循环称为一次 &lt;strong&gt;Round&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;语义分析与字节码生成过程：&lt;/strong&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;过程&lt;/th&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;实现类&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;标注检查&lt;/td&gt;
          &lt;td&gt;检查变量使用前是否已被声明、变量与赋值的数据类型是否匹配等；进行常量折叠&lt;/td&gt;
          &lt;td&gt;com.sun.tools.javac.comp.Attr &amp;lt;/br&amp;gt;com.sun.tools.javac.comp.Check&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;数据及控制流分析&lt;/td&gt;
          &lt;td&gt;检查局部变量使用前是否赋值、方法的每条路径是否都有返回值、是否受查异常都正确处理等&lt;/td&gt;
          &lt;td&gt;com.sun.tools.javac.comp.Flow&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;解语法糖&lt;/td&gt;
          &lt;td&gt;将语法糖还原为基础语法结构&lt;/td&gt;
          &lt;td&gt;com.sun.tools.javac.comp.TranTypes &amp;lt;/br&amp;gt;com.sun.tools.javac.comp.Lower&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;字节码生成&lt;/td&gt;
          &lt;td&gt;将语法树、符号表等信息转化为字节码并写入磁盘，并进行少量的代码添加和转化工作&lt;/td&gt;
          &lt;td&gt;com.sun.tools.javac.jvm.Gen &amp;lt;/br&amp;gt;com.sun.tools.javac.jvm.ClassWriter&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;语法糖（Syntactic Sugar）：&lt;/strong&gt;指在计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是能方便程序员使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Java 泛型 VS C# 泛型：&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;C#：通过类型膨胀实现的真实泛型&lt;/li&gt;
      &lt;li&gt;Java：通过类型擦除实现的伪泛型；它的泛型指在源码中存在，在编译为字节码后就替换为原生类型（Raw Type），所以在运行期中 ArrayList&amp;lt;int&amp;gt; 和 ArrayList&amp;lt;String&amp;gt; 是相同的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二-晚期运行期优化&quot;&gt;(二) 晚期（运行期）优化&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;解释器与编译器各有优势：&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;解释器可以让程序迅速启动和执行，且能节约内存&lt;/li&gt;
      &lt;li&gt;编译器随着运行时间推移，把更多的代码编译为本地代码，执行效率更高&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HotSpot 虚拟机中解释器和编译器搭配使用，称为&lt;strong&gt;混合模式（Mixed Mode）&lt;/strong&gt;，也可以通过参数设置为&lt;strong&gt;解释模式（Interpreted Mode）&lt;/strong&gt;和&lt;strong&gt;编译模式（Compiled Mode）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;HotSpot 虚拟机中内置两个即时编译器，分别称为 &lt;strong&gt;Client Compiler&lt;/strong&gt; 和 &lt;strong&gt;Server Compiler&lt;/strong&gt;，也简称 &lt;strong&gt;C1编译器&lt;/strong&gt;和 &lt;strong&gt;C2 编译器&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;为了在程序启动响应速度和运行效率之间取得最佳平衡，HotSpot 虚拟机采用&lt;strong&gt;分层编译（Tiered Compilation）&lt;/strong&gt;，具体分为：
    &lt;ul&gt;
      &lt;li&gt;第 0 层，解释执行，解释器不进行性能监控&lt;/li&gt;
      &lt;li&gt;第 1 层，C1 编译，进行简单、可靠的优化，加入必要的性能监控&lt;/li&gt;
      &lt;li&gt;第 2(+) 层，C2 编译，启动一些较为耗时的优化，以及一些需要根据性能监控来进行的不可靠的激进优化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;热点代码包括两种：被多次调用的方法 &amp;amp; 被多次执行的循环体&lt;/li&gt;
  &lt;li&gt;对于&lt;strong&gt;由循环体触发&lt;/strong&gt;的即时编译，编译器仍会以整个方法作为编译对象，这称为&lt;strong&gt;栈上替换/ OSR 编译（On Stack Replacement）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;主要的热点探测判定方式有：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;优点&lt;/th&gt;
      &lt;th&gt;缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;基于采用的热点探测（Sample Based Hot Spot Detection）&lt;/td&gt;
      &lt;td&gt;实现简单、高效；容易获取方法调用关系&lt;/td&gt;
      &lt;td&gt;难以精准确认一个方法的热度，容易受到线程阻塞或者其他外界因素影响&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;基于计数器的热点探测（Counter Based Hot Spot Detection）&lt;/td&gt;
      &lt;td&gt;实现麻烦，不能直接获取方法的调用关系&lt;/td&gt;
      &lt;td&gt;统计结果更加精确和严谨&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HotSpot 虚拟机使用&lt;strong&gt;基于计数器的热点探测&lt;/strong&gt;，且为每个方法准备了两类计数器：&lt;strong&gt;方法计数器（Invocation Counter）和回边计数器（Back Edge Counter）&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;方法调用计数器触发的即时编译：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91.png&quot; alt=&quot;方法调用计数器触发的即时编译&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果不做任何设置，方法调用计数器统计的是相对的执行频率，即一段时间内的调用次数。如果一定时间内，方法的调用次数没有达到阈值，那计数器值就会减少一半，这个过程称为&lt;strong&gt;衰减（Counter Decay）&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;回边计数器的阈值默认是间接计算得到：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Client 模式下：回边计数器阈值=方法调用计数器阈值 * OSR 比率/100&lt;/li&gt;
      &lt;li&gt;Server 模式下：回边计数器阈值=方法调用计数器阈值 * (OSR 比率 - 解释器监控比率)/100&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;回边计数器触发的即时编译：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91.png&quot; alt=&quot;回边计数器触发的即时编译&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;回边计数器统计的是绝对次数，不存在热度衰减的过程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;编译器的工作：&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;第一阶段：将字节码构成一种高级中间代码表示（High-Level Intermediate Representation，HIR）&lt;/li&gt;
      &lt;li&gt;第二阶段：从 HIR 中产生低级中间代码表示（Low-Level Intermediate Representation，LIR）&lt;/li&gt;
      &lt;li&gt;第三阶段：进行线性扫描算法（Linear Scan Register Allocation），在 LIR 上分配寄存器，产生机器代码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;公共字表达式消除：&lt;/strong&gt;如果一个表达式 E 已经计算过，并从计算后到现在 E 中变量的值不变，那么 E 则成为公共子表达式，可直接用之前计算的结果代替 E&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果优化仅限于程序基本块内，则称为&lt;strong&gt;局部公共子表达式（Local Common Subexpression Elimination）&lt;/strong&gt;；如果优化涵盖多个基本块，则称为&lt;strong&gt;全局公共子表达式（Global Common Subexpression Elimination）&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数组边界检查消除（Array Bounds Checking Elimination）&lt;/strong&gt;：在即时编译器中，在编译期根据数据流分析来进行数组的越界检查，以避免在运行期每次进行边界检查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;方法内联&lt;/strong&gt;：把目标方法的代码“复制”到发起调用的方法中，以避免发生真实的方法调用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java 虚拟机中，使用&lt;strong&gt;类型继承关系分析（Class Hierarchy Analysis，CHA）&lt;/strong&gt;来确定目前已加载的类中，某个接口是否有多于一种的实现，某个类是否有子类、子类是否为抽象类等信息，从而解决虚方法的内联问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Java 编译器内联：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ompnv884d.bkt.clouddn.com/Java%E7%BC%96%E8%AF%91%E5%99%A8%E5%86%85%E8%81%94.png&quot; alt=&quot;Java编译器内联&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;逃逸分析（Escape Analysis）&lt;/strong&gt;主要分析对象的动态作用域，分两种：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;方法逃逸：对象被外部方法引用，例如作为参数传递到其他方法&lt;/li&gt;
      &lt;li&gt;线程逃逸：对象被外部线程访问到，例如赋值给类变量或在其他线程中访问的实例变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若能证明一个对象不会逃逸，则可以进行如下优化：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;栈上分配（Stack Allocation）&lt;/strong&gt;：如果一个对象不会发生方法逃逸，则该对象可以在栈上分配内存。好处是对象会随栈帧出栈而销毁，减少 GC 的压力&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;同步消除（Synchronization Elimination）&lt;/strong&gt;：如果一个对象不会发生线程逃逸，则对该对象的同步措施可以消除&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;标量替换（Scalar Replacement）&lt;/strong&gt;：如果一个对象不会被外部访问，且该对象可拆散，则可以不创建该对象，而是直接创建若干被这个方法使用到的对象的成员变量来代替&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 19 Dec 2017 06:00:00 +0800</pubDate>
        <link>https://damondu.github.io//2017/12/19/java-virtual-machine-3/</link>
        <guid isPermaLink="true">https://damondu.github.io//2017/12/19/java-virtual-machine-3/</guid>
        
        <category>Java</category>
        
        
      </item>
    
  </channel>
</rss>
